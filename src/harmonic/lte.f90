! Lattice Thermal Energy, Neil Drummond, 12/2004-1/2005.
! Modified by B. Monserrat

! Calculates the frequencies and patterns of atomic displacement at the 
!    supercell G vectors. This is useful if you are interested in following
!    a mode.

! CHANGES TO CODE
! ===============
! 20/07/05 Added calculation of speed of sound for monatomic crystals.
!          (Needs eigenvectors of dynamical matrix.)
! 21/07/05 Bugfix: take min image of all prim-cell vectors w.r.t supercell.
! 12/11/05 Fix for nonzero translations: r->b+Rr instead of r->b+R(r-b)
! 30/01/08 Divided freq_dos into separate sets, to allow error estimates.
! 02/02/08 Bugfix: include multiple images where necessary.
! 29/02/08 Applied fix r->b=Rr instead of r->b+R(r-b) everywhere.
! 17/04/09 Eliminated binning of imaginary frequencies, to avoid large free
!          energy due to lowest-freq bin at T>0.  Tidied, introduced i2s, etc.
!          Inserted better min-image routine.
! 08/05/09 Sped up initialisation by eliminating min_image calls.
! 13/05/09 Added evaluation of frequencies on supercell G vectors.
! 18/05/09 Fixed min-image bug introduced on 17/04/09.  Removed more min-images.
! 20/04/10 Enabled calculation of pattern of atomic displacement at each G.
! 17/06/11 Introduced BLAS & LAPACK.  Fixed bug in randomisation of theta for
!          speed-of-sound calculation.
! 2016     Integrated into Caesar. See Caesar git history.

module lte_module
  use constants, only : dp
  use file_module
  implicit none
  
  ! Contains all the information generated by evaluate_freqs_on_grid.
  type LteReturn
    complex(dp), allocatable :: dynamical_matrices(:,:,:)
    real(dp),    allocatable :: frequencies(:,:)
    logical,     allocatable :: soft_modes(:,:)
    real(dp),    allocatable :: prefactors(:,:,:)
    real(dp),    allocatable :: displacements(:,:,:,:)
    real(dp),    allocatable :: k_displacements(:,:,:,:)
    complex(dp), allocatable :: polarisation_vectors(:,:,:,:)
  end type
  
  ! Contains the result of calculate_frequencies_and_polarisations
  type FreqsPolVecs
    real(dp),    allocatable :: frequencies(:)
    complex(dp), allocatable :: polarisation_vectors(:,:)
  end type
  
  interface new
    module procedure new_LteReturn
    module procedure new_FreqsPolVecs
  end interface
  
  interface drop
    module procedure drop_LteReturn
    module procedure drop_FreqsPolVecs
  end interface
  
contains

subroutine new_LteReturn(this,sc_size,no_modes,no_atoms)
  implicit none
  
  type(LteReturn), intent(out) :: this
  integer,         intent(in)  :: sc_size
  integer,         intent(in)  :: no_modes
  integer,         intent(in)  :: no_atoms
  
  allocate(this%dynamical_matrices(no_modes,no_modes,sc_size))
  allocate(this%frequencies(no_modes,sc_size))
  allocate(this%soft_modes(no_modes,sc_size))
  allocate(this%prefactors(no_atoms,no_modes,sc_size))
  allocate(this%displacements(3,no_atoms,no_modes,sc_size))
  allocate(this%k_displacements(3,no_atoms,no_modes,sc_size))
  allocate(this%polarisation_vectors(3,no_atoms,no_modes,sc_size))
end subroutine

subroutine new_FreqsPolVecs(this,no_modes)
  implicit none
  
  type(FreqsPolVecs), intent(out) :: this
  integer,            intent(in)  :: no_modes
  
  allocate(this%frequencies(no_modes))
  allocate(this%polarisation_vectors(no_modes,no_modes))
end subroutine

subroutine drop_LteReturn(this)
  implicit none
  
  type(LteReturn), intent(inout) :: this
  
  deallocate(this%dynamical_matrices)
  deallocate(this%frequencies)
  deallocate(this%prefactors)
  deallocate(this%displacements)
  deallocate(this%k_displacements)
  deallocate(this%polarisation_vectors)
end subroutine

subroutine drop_FreqsPolVecs(this)
  implicit none
  
  type(FreqsPolVecs), intent(inout) :: this
  
  deallocate(this%frequencies)
  deallocate(this%polarisation_vectors)
end subroutine

! ----------------------------------------------------------------------
! Returns delta_prim(k,b,a), the set of G-vectors which are equivalent to 
!    supercell G-vector k, modulo the supercell lattice.
! The only G-vectors given are such that the real-space distance between
!    atom a in the primitive (gamma-point) cell and atom b at G-vector k
!    is minimum, within a tolerance.
! Result is given in fractional supercell co-ordinates.
! ----------------------------------------------------------------------
function calculate_delta_prim(structure,structure_sc) result(delta_prim)
  use structure_module
  use min_images_module
  use string_module
  implicit none
  
  type(StructureData), intent(in) :: structure
  type(StructureData), intent(in) :: structure_sc
  type(MinImages), allocatable    :: delta_prim(:,:,:)
  
  real(dp) :: delta_r(3)
  real(dp) :: delta_r_corr(3)  
  integer  :: p,im
  
  integer :: atom_1_prim,atom_2_prim
  integer :: atom_1_sc_1,atom_2_sc_1,atom_2_sc_p

  ! Work out number of equivalent images and Delta Prim. Lattice Vectors
  ! for pairs of atoms (used in evaluation of force-constant matrix).
  allocate(delta_prim( structure_sc%sc_size, &
                     & structure%no_atoms,   &
                     & structure%no_atoms))
  do atom_1_prim=1,structure%no_atoms
    atom_1_sc_1 = structure_sc%gvec_and_prim_to_atom(atom_1_prim,1)
    do atom_2_prim=1,structure%no_atoms
      atom_2_sc_1 = structure_sc%gvec_and_prim_to_atom(atom_2_prim,1)
      delta_r_corr = matmul( structure_sc%recip_lattice, &
                           &   structure_sc%atoms(:,atom_2_sc_1) &
                           & - structure_sc%atoms(:,atom_1_sc_1))
      do p=1,structure_sc%sc_size
        ! Work out minimum distance(s) between atom_1 at gamma and
        !    atom_2 at G-vector p.
        atom_2_sc_p = structure_sc%gvec_and_prim_to_atom(atom_2_prim,p)
        delta_r = matmul( structure_sc%recip_lattice, &
                        &   structure_sc%atoms(:,atom_2_sc_p) &
                        & - structure_sc%atoms(:,atom_1_sc_1))
        delta_prim(p,atom_2_prim,atom_1_prim) = &
           & min_images_brute_force(delta_r,structure_sc)
        
        ! Turn this into the corresponding difference(s) of lattice vectors.
        do im=1,size(delta_prim(p,atom_2_prim,atom_1_prim))
          delta_prim(p,atom_2_prim,atom_1_prim)%images(:,im) = &
             & delta_prim(p,atom_2_prim,atom_1_prim)%images(:,im) &
                                       & - delta_r_corr
        enddo
      enddo
    enddo
  enddo
end function

! ----------------------------------------------------------------------
! Construct the dynamical matrix for a given k vector.
! ----------------------------------------------------------------------
function construct_dynamical_matrix(kvec,structure,structure_sc, &
   & force_constants,delta_prim) result(dynamical_matrix)
  use constants, only : pi
  use string_module
  use structure_module
  use min_images_module
  implicit none
  
  real(dp),            intent(in) :: kvec(3)
  type(StructureData), intent(in) :: structure
  type(StructureData), intent(in) :: structure_sc
  real(dp),            intent(in) :: force_constants(:,:,:)
  type(MinImages),     intent(in) :: delta_prim(:,:,:)
  
  complex(dp), allocatable :: dynamical_matrix(:,:)
  
  integer :: p,n,m,im
  integer :: mode_n,mode_m
  complex(dp) :: tempc
  complex(dp), allocatable :: exp_ikd(:,:,:)
  real(dp) :: k_dot_D
  
  ! Precompute exp(-ik.(R-R')) to go in the dynamical matrix.
  allocate(exp_ikd( structure_sc%sc_size, &
                  & structure%no_atoms,   &
                  & structure%no_atoms))
  do n=1,structure%no_atoms
    do m=1,structure%no_atoms
      do p=1,structure_sc%sc_size
        tempc = cmplx(0.0_dp,0.0_dp,dp)
        do im=1,size(delta_prim(p,m,n))
          k_dot_D = -dot_product(2*pi*kvec,delta_prim(p,m,n)%images(:,im))
          tempc = tempc + cmplx(cos(k_dot_d),sin(k_dot_d),dp)
        enddo
        exp_ikd(p,m,n) = tempc / size(delta_prim(p,m,n))
      enddo
    enddo
  enddo
  
  ! Evaluate the dynamical matrix.
  allocate(dynamical_matrix(structure%no_modes,structure%no_modes))
  dynamical_matrix = cmplx(0.0_dp,0.0_dp,dp)
  do n=1,structure%no_atoms
    mode_n = (n-1)*3+1
    do m=1,structure%no_atoms
      mode_m = (m-1)*3+1
      do p=1,structure_sc%sc_size
        dynamical_matrix(mode_m:mode_m+2, mode_n:mode_n+2) =         &
           &   dynamical_matrix(mode_m:mode_m+2, mode_n:mode_n+2)    &
           & + force_constants (mode_m:mode_m+2, mode_n:mode_n+2, p) &
           & * exp_ikd(p,m,n)
      enddo
    enddo
  enddo
  
  ! Enforce Hermiticity on the dynamical matrix.
  dynamical_matrix = (dynamical_matrix + conjg(transpose(dynamical_matrix)))/2
end function

! ----------------------------------------------------------------------
! Diagonalise the dynamical matrix.
! This subroutine returns the polarisation vectors as well.
! It is not optimised for speed.
! ----------------------------------------------------------------------
function calculate_frequencies_and_polarisations(dynamical_matrix) &
   & result(output)
  use linear_algebra
  use structure_module
  implicit none
  
  complex(dp), intent(in) :: dynamical_matrix(:,:)
  type(FreqsPolVecs)      :: output
  
  integer :: no_modes
  integer :: n,m
  
  type(ComplexEigenstuff) :: estuff
  
  no_modes = size(dynamical_matrix,1)
  
  call new(output,no_modes)
  
  ! Diagonalise dynamical matrix.
  estuff = calculate_eigenstuff(dynamical_matrix)
  
  ! Calculate frequencies and polarisation vectors.
  do n=1,no_modes
    m = no_modes - n + 1
    
    if (estuff%evals(m)>=0.0_dp) then
      ! Unstable mode.
      output%frequencies(n) = - dsqrt(estuff%evals(m))
    else
      ! Stable mode.
      output%frequencies(n) = dsqrt(- estuff%evals(m))
    endif
    
    output%polarisation_vectors(:,n) = estuff%evecs(:,m)
  enddo
end function

! ----------------------------------------------------------------------
! This function returns the mean thermal energy of an isolated harmonic
! oscillator of frequency omega (in a.u.).  T is the temperature in Kelvin.
! ----------------------------------------------------------------------
real(dp) function harmonic_energy(temperature,omega)
  use constants, only : kb_in_au
  implicit none
  
  real(dp), intent(in) :: temperature
  real(dp), intent(in) :: omega
  
  real(dp) :: denominator
  
  if(temperature<=0.d0)then
    ! Zero-point energy.
    harmonic_energy=0.5d0*omega
  else
    denominator=EXP(omega/(kb_in_au*temperature))-1.d0
    if(denominator>0.d0)then
      ! General case.
      harmonic_energy=(1.d0/denominator+0.5d0)*omega
    else
      ! High-temperature limit.
      harmonic_energy = kb_in_au*temperature
    endif ! denominator>0
  endif ! temperature=0
end function

! ----------------------------------------------------------------------
! This function returns the mean free energy of an isolated harmonic
! oscillator of frequency omega (in a.u.). Temperature is in Kelvin.
! ----------------------------------------------------------------------
function harmonic_free_energy(temperature,omega) result(output)
  use constants, only : kb_in_au
  implicit none
  
  real(dp), intent(in) :: temperature
  real(dp), intent(in) :: omega
  real(dp)             :: output
  
  real(dp) :: difference
  real(dp) :: thermal_energy
  
  if(temperature<=0.0_dp)then
    ! Zero-point energy.
    output=0.5_dp*omega
  else
    thermal_energy = kb_in_au*temperature
    difference = 1.0_dp-dexp(-omega/thermal_energy)
    if (difference>0.0_dp) then
      output = 0.5_dp*omega + thermal_energy*dlog(difference)
    else
      ! High-temperature limit.
      output = -huge(0.0_dp)
    endif
  endif
end function

! ----------------------------------------------------------------------
! Calculate the frequency density-of-states by Monte Carlo sampling of
! the Brillouin zone.
! ----------------------------------------------------------------------
subroutine generate_dos(structure,structure_sc,delta_prim, &
   & force_consts,temperature,free_energy_filename,freq_dos_filename)
  use string_module
  use file_module
  use structure_module
  use min_images_module
  implicit none
  
  type(StructureData), intent(in) :: structure
  type(StructureData), intent(in) :: structure_sc
  type(MinImages),     intent(in) :: delta_prim(:,:,:)
  real(dp),            intent(in) :: force_consts(:,:,:)
  real(dp),            intent(in) :: temperature
  type(String),        intent(in) :: free_energy_filename
  type(String),        intent(in) :: freq_dos_filename
  
  integer,parameter :: no_bins=1000,no_prelims=10000,no_samples=1000000
  real(dp),parameter :: freq_tol=1.0e-8_dp,safety_factor=1.15_dp
  
  integer :: i_sample,i_freq,i_bin
  real(dp) :: max_freq,min_freq,frac(3),kpoint(3),bin_width,&
    &freq_dos(no_bins),free_energy,omega
  
  complex(dp), allocatable :: dyn_mat(:,:)
  type(FreqsPolVecs)       :: frequencies
  
  ! file units
  integer :: free_energy_file
  integer :: freq_dos_file
  
  ! Initialise the random number generator
  call random_seed()
  
  max_freq=-1.0_dp
  min_freq=huge(1.0_dp)
  
  ! Establish (approximate) maximum and minimum frequencies and hence
  ! choose the bin width.
  do i_sample=1,no_prelims
    call random_number(frac)
    kpoint = matmul(structure_sc%recip_supercell,frac)/structure_sc%sc_size
    dyn_mat = construct_dynamical_matrix(kpoint,structure,structure_sc, &
       & force_consts,delta_prim)
    frequencies = calculate_frequencies_and_polarisations(dyn_mat)
    
    min_freq = min(min_freq,frequencies%frequencies(1))
    max_freq = max(max_freq,frequencies%frequencies(structure%no_modes))
  enddo
  
  if (max_freq<=0.0_dp) then
    call print_line('The system is pathologically unstable.')
    call err()
  endif
  
  bin_width=safety_factor*max_freq/dble(no_bins)
  freq_dos=0.0_dp
  
  do i_sample=1,no_samples
    call random_number(frac)
    kpoint = matmul(structure_sc%recip_supercell,frac)/structure_sc%sc_size
    dyn_mat = construct_dynamical_matrix(kpoint,structure,structure_sc, &
       & force_consts,delta_prim)
    frequencies = calculate_frequencies_and_polarisations(dyn_mat)
    
    do i_freq=1,structure%no_modes
      ! Only bin positive frequencies.
      if (frequencies%frequencies(i_freq) > -freq_tol) then
        i_bin = max(1,ceiling(frequencies%frequencies(i_freq)/bin_width))
        if (i_bin>no_bins) then
          call print_line('Frequency too high to be binned.')
          call err()
        endif
        freq_dos(i_bin) = freq_dos(i_bin)+1.0_dp
      endif
    enddo
  enddo
  
  free_energy = 0.0_dp
  do i_bin=1,no_bins
    omega = bin_width*(dble(i_bin)-0.5_dp)
    free_energy = free_energy                               &
              & +   freq_dos(i_bin)                         &
              &   * harmonic_free_energy(temperature,omega) &
              &   / no_samples
  enddo
  
  free_energy_file = open_write_file(free_energy_filename)
  call print_line(free_energy_file,free_energy)
  close(free_energy_file)
  
  ! Normalise frequency DoS so that its integral is the number of
  !    degrees of freedom in the primitive cell. Note that the total
  !    number of frequencies sampled is no_samples*structure%no_modes.
  ! (Imaginary frequencies are ignored, however.)
  freq_dos = freq_dos/(no_samples*bin_width)
  
  ! Write out the frequency DoS.
  freq_dos_file = open_write_file(freq_dos_filename)
  do i_bin=1,no_bins
    call print_line( freq_dos_file, &
                   & bin_width*(i_bin-0.5_dp)//' '//freq_dos(i_bin))
  enddo
  close(freq_dos_file)
end subroutine

! ----------------------------------------------------------------------
! Use the frequency density-of-states to evaluate the lattice thermal
! energy of the crystal as a function of the temperature in Kelvin.
! Repeat this for each set of frequency DoS data, to estimate the error
! in the LTFE.
! ----------------------------------------------------------------------
subroutine calc_lte(bin_width,temperature,freq_dos,tdependence1_filename)
  use constants,      only : max_bin, no_fdos_sets
  use linear_algebra, only : ddot
  use string_module
  implicit none
  
  real(dp), intent(in) :: bin_width
  real(dp), intent(in) :: temperature
  real(dp), intent(in) :: freq_dos(:,:)
  
  ! File name
  type(String), intent(in) :: tdependence1_filename
  
  ! File unit
  integer :: tdependence1_file
  
  integer :: bin,j
  real(dp) :: omega,lte_val,lte_sq,E_H(0:max_bin),lte,lte_err
  
  do bin=0,max_bin
    ! omega is the frequency in the middle of the corresponding bin.
    omega=(DBLE(bin)+0.5d0)*bin_width
    ! Array of harmonic energies at each frequency.
    E_H(bin)=harmonic_energy(temperature,omega) 
  enddo ! bin
  lte=0.d0 ; lte_sq=0.d0
  do j=1,no_fdos_sets
    ! LAPACK commented out because it isn't working. 9/1/2017
    ! lte_val=ddot(max_bin+1,freq_dos(0,j),1,E_H(0),1)
    lte_val = dot_product(freq_dos(:,j),E_H(:))
    lte=lte+lte_val ; lte_sq=lte_sq+lte_val**2
  enddo ! j
  lte=bin_width*lte/DBLE(no_fdos_sets)
  lte_sq=bin_width**2*lte_sq/DBLE(no_fdos_sets)
  lte_err=SQRT((lte_sq-lte**2)/DBLE(no_fdos_sets-1))
  write(*,'(1x,a,es18.10,a,es10.2)')'Done.  LTE per primitive cell : ', &
    &lte,' +/- ',lte_err
   
  tdependence1_file = open_write_file(tdependence1_filename)
  write(tdependence1_file,*) lte
  close(tdependence1_file)
end subroutine

! ----------------------------------------------------------------------
! Use the frequency density-of-states to evaluate the lattice thermal
! free energy of the crystal as a function of the temperature in Kelvin.
! Repeat this for each set of frequency DoS data, to estimate the error
! in the LTFE.
! ----------------------------------------------------------------------
subroutine calc_ltfe(bin_width,temperature,freq_dos,tdependence2_filename)
  use constants, only : max_bin, no_fdos_sets
  use string_module
  implicit none
  
  real(dp), intent(in) :: bin_width
  real(dp), intent(in) :: temperature
  real(dp), intent(in) :: freq_dos(:,:)
  
  ! File name
  type(String), intent(in) :: tdependence2_filename
  
  ! File unit
  integer :: tdependence2_file
  
  integer :: bin,j
  real(dp) :: omega,ltfe_sq,ltfe_val,FE_H(0:max_bin),ltfe,ltfe_err
  
  do bin=0,max_bin
    ! omega is the frequency in the middle of the corresponding bin.
    omega=(DBLE(bin)+0.5d0)*bin_width
    ! Array of harmonic energies at each frequency.
    FE_H(bin)=harmonic_free_energy(temperature,omega)
  enddo ! bin
  ltfe=0.d0 ; ltfe_sq=0.d0
  do j=1,no_fdos_sets
    ltfe_val=DOT_PRODUCT(freq_dos(:,j),FE_H(:))
    ltfe=ltfe+ltfe_val ; ltfe_sq=ltfe_sq+ltfe_val**2
  enddo ! j
  ltfe=bin_width*ltfe/DBLE(no_fdos_sets)
  ltfe_sq=bin_width**2*ltfe_sq/DBLE(no_fdos_sets)
  ltfe_err=SQRT((ltfe_sq-ltfe**2)/DBLE(no_fdos_sets-1))
  write(*,'(1x,a,es18.10,a,es10.2)')'and LTFE per primitive cell   : ', &
    &ltfe,' +/- ',ltfe_err
  
  tdependence2_file = open_write_file(tdependence2_filename)
  write(tdependence2_file,*) ltfe
  close(tdependence2_file)
end subroutine

! ----------------------------------------------------------------------
! This subroutine generates a dispersion_curve.dat file, which contains
! all the branches of the dispersion curve in a format that xmgrace 
! can read.  The branches of the dispersion curve are plotted against
! the total distance travelled along the specified lines.
! ----------------------------------------------------------------------
subroutine generate_dispersion(structure,structure_sc,&
   & delta_prim,force_consts,path,phonon_dispersion_curve_filename, &
   & high_symmetry_points_filename)
  use constants, only : pi
  use utils, only : l2_norm
  use file_module
  use string_module
  use structure_module
  use min_images_module
  implicit none
  
  type(StructureData), intent(in) :: structure
  type(StructureData), intent(in) :: structure_sc
  type(MinImages),     intent(in) :: delta_prim(:,:,:)
  real(dp),            intent(in) :: force_consts(:,:,:)
  real(dp),            intent(in) :: path(:,:)
  type(String),        intent(in) :: phonon_dispersion_curve_filename
  type(String),        intent(in) :: high_symmetry_points_filename
  
  integer                  :: no_paths
  real(dp),    allocatable :: kpoints(:,:)
  real(dp),    allocatable :: path_length(:)
  real(dp),    allocatable :: cumulative_length(:)
  integer,     allocatable :: no_points(:)
  real(dp)                 :: kpoint(3)
  complex(dp), allocatable :: dyn_mat(:,:)
  type(FreqsPolVecs)       :: frequencies
  
  ! File units.
  integer :: phonon_dispersion_curve_file
  integer :: high_symmetry_points_file
  
  ! Temporary variables.
  integer :: i,j
  
  no_paths = size(path,2)-1
  
  ! Transform k-points into reciprocal space.
  allocate(kpoints(3,no_paths+1))
  kpoints = 2*pi*matmul(structure%recip_lattice, path)
  
  ! Work out distances in k-space.
  allocate(path_length(no_paths))
  do i=1,no_paths
    path_length(i) = l2_norm(kpoints(:,i+1)-kpoints(:,i))
  enddo
  
  allocate(cumulative_length(no_paths+1))
  cumulative_length(1) = 0.0_dp
  do i=2,no_paths+1
    cumulative_length(i) = cumulative_length(i-1)+path_length(i-1)
  enddo
  
  ! Space sampling points across the path, in proportion with path length.
  allocate(no_points(no_paths))
  do i=1,no_paths
    no_points(i) = nint(1000*path_length(i)/cumulative_length(no_paths+1))
  enddo
  
  ! Write path lengths to file.
  high_symmetry_points_file = open_write_file(high_symmetry_points_filename)
  do i=1,no_paths+1
    call print_line(high_symmetry_points_file,i//' '//cumulative_length(i))
  enddo
  close(high_symmetry_points_file)
  
  ! Travel along k-space paths, calculating frequencies at each point.
  phonon_dispersion_curve_file = &
     & open_write_file(phonon_dispersion_curve_filename)
  do i=1,no_paths
    do j=0,no_points(i)-1
      kpoint = ((no_points(i)-j)*kpoints(:,i)+j*kpoints(:,i+1))/no_points(i)
      dyn_mat = construct_dynamical_matrix(kpoint,structure,structure_sc, &
         & force_consts,delta_prim)
      frequencies = calculate_frequencies_and_polarisations(dyn_mat)
      call print_line(phonon_dispersion_curve_file, &
         & cumulative_length(i)+j*path_length(i)//' '// &
         & frequencies%frequencies)
    enddo
  enddo
  
  ! Calculate frequencies at final k-space point.
  kpoint = kpoints(:,no_paths+1)
  dyn_mat = construct_dynamical_matrix(kpoint,structure,structure_sc, &
     & force_consts,delta_prim)
  frequencies = calculate_frequencies_and_polarisations(dyn_mat)
  call print_line(phonon_dispersion_curve_file, &
     & (cumulative_length(no_paths+1))//' '//frequencies%frequencies)
  
  close(phonon_dispersion_curve_file)
end subroutine

! ----------------------------------------------------------------------
! This subroutine calculates the mean speed of sound by evaluating
! domega/dk at Gamma and averaging over all directions.  The
! directions are uniformly distributed.  This subroutine only works
! for monatomic crystals at present.  The polarisation vectors are
! calculated for each k, and the dot product of k with the
! polarisation vectors are calculated.  The branch with the largest dot
! product is the longitudinal branch, whilst the other two branches
! are the transverse modes.
! ----------------------------------------------------------------------
subroutine calculate_speed_sound(structure,structure_sc, &
   & force_constants,delta_prim)
  use constants,   only : pi
  use structure_module
  use min_images_module
  use file_module
  implicit none
  
  type(StructureData), intent(in) :: structure
  type(StructureData), intent(in) :: structure_sc
  real(dp),            intent(in) :: force_constants(:,:,:)
  type(MinImages),     intent(in) :: delta_prim(:,:,:)
  
  real(dp) :: kvec(3),cos_theta,sin_theta,phi,c_tr_tot,c_tr, &
    &c2_tr_tot,c2_tr,c_ln_tot,c_ln,c2_ln_tot,c2_ln,err_tr,err_ln,c(3), &
    &kunit(3),pol_vec_real(3,3),dot_prod(3),temp,c_tr_old,c_ln_old
  complex(dp), allocatable :: dynamical_matrix(:,:)
  type(FreqsPolVecs) :: frequencies_polarisations
  integer :: i,no_samples,k,k2
  real(dp),parameter :: err_tol=1.d-3
  integer,parameter :: max_samples=1000000
  logical,parameter :: verbose=.FALSE.
  real(dp) :: rand
  
  real(dp) :: small_k_scale
  real(dp) :: kmag

  if (structure%no_atoms/=1) then
    call print_line('At the moment this program can only work out the speed &
       &of sound in materials with a single atom per primitive cell.')
    call err()
  endif
  
  ! Initialise the random number generator
  call random_seed()
  
  ! "Small" distance in k space, determined by size of supercell.
  ! Factor of 2pi included.
  small_k_scale=2*pi*structure_sc%volume**(-1/3.0_dp)

  ! First guess at a suitable radius of sphere in k-space for computing
  ! derivatives of omega w.r.t. k.
  kmag=0.75d0*small_k_scale

  c_tr_old=HUGE(1.d0) ; c_ln_old=HUGE(1.d0)

  ! Reduce kmag until the calculated sound speeds have converged.

  do

    c_tr_tot=0.d0  ; c_ln_tot=0.d0
    c2_tr_tot=0.d0 ; c2_ln_tot=0.d0
    no_samples=max_samples

    do i=1,max_samples

      ! Choose random k vector on sphere of radius kmag.
      call random_number(rand)
      cos_theta=1.d0-2.d0*rand
      call random_number(rand)
      phi=rand*2*pi
      sin_theta=SQRT(1.d0-cos_theta**2)
      kunit = (/sin_theta*COS(phi),sin_theta*SIN(phi),cos_theta/)
      kvec = matmul(structure_sc%lattice,kmag*kunit)

      ! Calculate corresponding eigenfrequencies.
      dynamical_matrix = construct_dynamical_matrix(kvec,structure, &
         & structure_sc,force_constants,delta_prim)
      frequencies_polarisations = &
         & calculate_frequencies_and_polarisations(dynamical_matrix)
      
      if (any(frequencies_polarisations%frequencies<0.0_dp)) then
        write(*,*)'Imaginary frequencies found.'
        write(*,*)'In terms of the primitive reciprocal lattice vectors, &
          &the k-point is:'
        write(*,*) dot_product(kvec,structure%lattice(1,:)), &
                 & dot_product(kvec,structure%lattice(2,:)), &
                 & dot_product(kvec,structure%lattice(3,:))
        write(*,*)'The frequencies are:'
        write(*,*)frequencies_polarisations%frequencies
        call print_line('Cannot calculate speed of sound for unstable &
           &lattices.')
        call err()
      endif

      ! Speed of sound corresponding to first three (acoustic) branches.
      c = frequencies_polarisations%frequencies/kmag

      ! Work out dot products of corresponding polarisation vectors
      ! with unit vector in direction of wave vector.
      pol_vec_real(:,:)=real( frequencies_polarisations%polarisation_vectors,&
                            & dp)
      dot_prod = abs(matmul(pol_vec_real,kunit))

      ! Arrange the three sound speeds in ascending order of dot
      ! product of k with polarisation vector.  The third component
      ! should be the longitudinal one, the first two should be
      ! the transverse components.
      do k=1,2
        do k2=k+1,3
          if(dot_prod(k)>dot_prod(k2))then
            temp=dot_prod(k) ; dot_prod(k)=dot_prod(k2) ; dot_prod(k2)=temp
            temp=c(k) ; c(k)=c(k2) ; c(k2)=temp
          endif ! Swap needed
        enddo ! k2
      enddo ! k

      ! Accumulate sound-speed statistics.
      c_tr_tot=c_tr_tot+c(1)+c(2)
      c_ln_tot=c_ln_tot+c(3)
      c2_tr_tot=c2_tr_tot+c(1)**2+c(2)**2
      c2_ln_tot=c2_ln_tot+c(3)**2

      ! Check whether we have desired accuracy level.
      if(i>=20)then
        c2_ln=c2_ln_tot/DBLE(i)
        c_ln=c_ln_tot/DBLE(i)
        err_ln=SQRT((c2_ln-c_ln**2)/DBLE(i-1))
        if(err_ln<err_tol*c_ln)then
          no_samples=i
          exit
        endif
      endif ! i>20

    enddo ! i

    ! Mean & standard error in mean for transverse speed.
    c_tr=c_tr_tot/DBLE(2*no_samples)
    c2_tr=c2_tr_tot/DBLE(2*no_samples)
    err_tr=SQRT((c2_tr-c_tr**2)/DBLE(2*no_samples-1))

    ! Mean & standard error in mean for longitudinal speed.
    c_ln=c_ln_tot/DBLE(no_samples)
    c2_ln=c2_ln_tot/DBLE(no_samples)
    err_ln=SQRT((c2_ln-c_ln**2)/DBLE(no_samples-1))

    if(verbose)then
      if(no_samples==max_samples)write(*,*)'Warning: have not reached &
        &desired error bar.'
      write(*,*)'Radius of k-space sphere : ',kmag
      write(*,*)'Speed of sound (a.u.)'
      write(*,*)'Transverse   : ',c_tr,' +/- ',err_tr
      write(*,*)'Longitudinal : ',c_ln,' +/- ',err_ln
      write(*,*)
    endif ! verbose

    if(ABS(c_tr-c_tr_old)<2.d0*err_tr.AND.ABS(c_ln-c_ln_old)<2.d0*err_ln)exit
    c_tr_old=c_tr
    c_ln_old=c_ln

    kmag=kmag*0.75d0

  enddo ! reduce kmag

  if(verbose)write(*,*)'Final results:'
  write(*,*)'Radius of k-space sphere : ',kmag
  write(*,*)'Please check this is sensible by examining a dispersion curve.'
  write(*,*)

  write(*,*)'Speed of sound (a.u.)'
  write(*,*)'Transverse   : ',c_tr,' +/- ',err_tr
  write(*,*)'Longitudinal : ',c_ln,' +/- ',err_ln
  write(*,*)
end subroutine

! ----------------------------------------------------------------------
! Evaluate the set of phonon frequencies on the supercell G vectors.
! Average the corresponding energies (for testing purposes).
! Write out the real part of the non-mass-reduced polarisation vector, which
! is the pattern of displacement corresponding to the normal mode.
! ----------------------------------------------------------------------
function evaluate_freqs_on_grid(structure,structure_sc,force_constants) &
   & result(output)
  use constants, only : pi
  use utils, only : l2_norm
  use string_module
  use structure_module
  use min_images_module
  use file_module
  implicit none
  
  type(StructureData), intent(in) :: structure
  type(StructureData), intent(in) :: structure_sc
  real(dp),            intent(in) :: force_constants(:,:,:)
  type(LteReturn)                 :: output
  
  integer :: i,ig,index1,index2,p,n,atom1
  real(dp) :: GdotR
  real(dp) :: disp_pattern(3)
  real(dp) :: kdisp_pattern(3)
  real(dp) :: tot_disp_patt
  complex(dp) :: non_mr_pol_vec(3,structure%no_atoms)
  complex(dp) :: expiGdotR(structure_sc%sc_size)
  complex(dp) :: kpol_vec(3,structure%no_atoms)
  real(dp),parameter :: tol_omega=1.d-6 ! For judging whether modes are soft.
  real(dp) :: prefactor
  
  type(MinImages), allocatable :: delta_prim(:,:,:)
  real(dp),        allocatable :: frequencies(:,:)
  complex(dp),     allocatable :: polarisation_vectors(:,:,:)
  
  type(FreqsPolVecs) :: frequencies_polarisations
  real(dp),    allocatable :: omega(:)
  complex(dp), allocatable :: pol_vec(:,:)
  
  delta_prim = calculate_delta_prim(structure,structure_sc)
  
  ! Calculate dynamical matrices, and their eigenstuff.
  allocate(frequencies(structure%no_modes,structure_sc%sc_size))
  allocate(polarisation_vectors( structure%no_modes, &
                               & structure%no_modes, &
                               & structure_sc%sc_size))
  call new(output, &
     & structure_sc%sc_size,structure%no_modes,structure_sc%no_atoms)
  
  ! Transform G-vectors into reciprocal space.
  do i=1,structure_sc%sc_size
    output%dynamical_matrices(:,:,i) = construct_dynamical_matrix( &
       & real(structure_sc%gvectors(:,i),dp),                &
       & structure, structure_sc, force_constants, delta_prim)
    
    frequencies_polarisations = calculate_frequencies_and_polarisations( &
       & output%dynamical_matrices(:,:,i))
    frequencies(:,i) = frequencies_polarisations%frequencies
    polarisation_vectors(:,:,i) = &
       & frequencies_polarisations%polarisation_vectors
  enddo
  
  ! Evaluate the frequencies at each supercell G vector.
  output%soft_modes=.false.
  do ig=1,structure_sc%sc_size
    output%frequencies(:,ig) = &
       & frequencies(:,min(ig,structure_sc%paired_gvec(ig)))
    omega = frequencies(:,min(ig,structure_sc%paired_gvec(ig)))
    pol_vec = polarisation_vectors(:,:,ig)
    
    ! Store exp(iG.R_p).
    ! The negative is used because the matrix of force constants is 
    !    the transpose of the usual expression in derivations 
    !    that lead to a positive exponential.
    do p=1,structure_sc%sc_size
      GdotR = -dot_product(matmul( &
         & structure_sc%gvectors(:,min(ig,structure_sc%paired_gvec(ig))), &
         & structure_sc%recip_supercell), &
         & structure_sc%gvectors(:,p))*2*pi/structure_sc%sc_size
      expiGdotR(p) = cmplx(cos(gdotr),sin(gdotr),dp)
    enddo
    
    do index2=1,structure%no_modes
      if (omega(index2)<-tol_omega) then
        output%soft_modes(index2,ig) = .true.
      endif
      
      ! Compute the non-mass-reduced polarisation vector.
      do n=1,structure%no_atoms
        do i=1,3
          index1 = (n-1)*3 + i
          non_mr_pol_vec(i,n) = pol_vec(index1,index2) &
                            & / dsqrt(structure%mass(n))
          kpol_vec(i,n)=pol_vec(index1,index2)
        enddo
      enddo
      
      disp_pattern=0.0_dp
      kdisp_pattern=0.0_dp
      tot_disp_patt=0.0_dp
      do atom1=1,structure_sc%no_atoms
        ! Displacement pattern: polarisation vector times exp(iG.R).
        if (ig == structure_sc%paired_gvec(ig)) then
          ! Note only the real part is taken
          disp_pattern = real(                                      &
             &   non_mr_pol_vec(:,structure_sc%atom_to_prim(atom1)) &
             & * expiGdotR(structure_sc%atom_to_gvec(atom1))        &
             & , dp)
          kdisp_pattern = real(kpol_vec(:,structure_sc%atom_to_prim(atom1)))
          prefactor = 1.0_dp
        elseif (ig < structure_sc%paired_gvec(ig)) then
          disp_pattern = real(                                      &
             &   non_mr_pol_vec(:,structure_sc%atom_to_prim(atom1)) &
             & * expiGdotR(structure_sc%atom_to_gvec(atom1))        &
             & , dp)
          kdisp_pattern = real(                               &
             &   kpol_vec(:,structure_sc%atom_to_prim(atom1)) &
             & * expiGdotR(structure_sc%atom_to_gvec(atom1))  &
             & , dp)
          prefactor = dsqrt(2.0_dp)
        else
          disp_pattern = aimag(                                     &
             &   non_mr_pol_vec(:,structure_sc%atom_to_prim(atom1)) &
             & * expiGdotR(structure_sc%atom_to_gvec(atom1)))
          kdisp_pattern = aimag(                              &
             &   kpol_vec(:,structure_sc%atom_to_prim(atom1)) &
             & * expiGdotR(structure_sc%atom_to_gvec(atom1)))
          prefactor = dsqrt(2.0_dp)
        endif
        
        tot_disp_patt = tot_disp_patt + l2_norm(disp_pattern)
        
        output%prefactors(atom1,index2,ig) = prefactor
        output%displacements(:,atom1,index2,ig) = disp_pattern
        output%k_displacements(:,atom1,index2,ig) = kdisp_pattern
        output%polarisation_vectors(:,atom1,index2,ig) = &
           & non_mr_pol_vec(:,structure_sc%atom_to_prim(atom1))
      enddo
    enddo
    
    if(tot_disp_patt<1.d-8)then
      call print_line('')
      call print_line('Error: total displacement < 1e-8.')
      call print_line('Total displacement: '//tot_disp_patt)
      call err()
    endif
  enddo
end function

! ----------------------------------------------------------------------
! Main program. (Split into four modes)
! ----------------------------------------------------------------------
subroutine lte_1(structure,structure_sc,force_constants, &
   & temperature,free_energy_filename,freq_dos_filename, &
   & tdependence1_filename,tdependence2_filename)
  use constants, only : dp
  use string_module
  use structure_module
  use min_images_module
  use file_module
  implicit none
  
  ! ----------------------------------------
  ! Inputs
  ! ----------------------------------------
  type(StructureData), intent(in) :: structure
  type(StructureData), intent(in) :: structure_sc
  real(dp),            intent(in) :: force_constants(:,:,:)
  real(dp),            intent(in) :: temperature
  
  ! ----------------------------------------
  ! filenames
  ! ----------------------------------------
  type(String), intent(in) :: free_energy_filename
  type(String), intent(in) :: freq_dos_filename
  type(String), intent(in) :: tdependence1_filename
  type(String), intent(in) :: tdependence2_filename
  
  ! ----------------------------------------
  ! previously global variables
  ! ----------------------------------------
  real(dp) :: bin_width
  real(dp), allocatable :: freq_dos(:,:)
  
  type(MinImages), allocatable :: delta_prim(:,:,:)
  
  delta_prim = calculate_delta_prim(structure,structure_sc)

  write(*,*)'Temperature (K)                    :',temperature
  if (temperature<0.0_dp) then
    call print_line('Temperature should be non-negative.')
    call err()
  endif
  
  if (temperature<=0.0_dp) then
    write(*,*)'(i.e. the zero-point energy is to be calculated.)'
  endif
  
  write(*,*)

  write(*,*)'The mean thermal energy and the free energy will &
    &be calculated.'
  write(*,*)'Calculating the frequency density-of-states function...'
  call generate_dos(structure,structure_sc,delta_prim, &
   & force_constants,temperature,free_energy_filename,freq_dos_filename)
  write(*,*)'Done.  Frequency density-of-states function written to &
    &freq_dos.dat.  (Please view this file using XMGrace.)'
  write(*,*)

  write(*,*)'Calculating the lattice thermal energy (LTE) and free energy &
    &(LTFE)...'
  call calc_lte(bin_width,temperature,freq_dos,tdependence1_filename)
  call calc_ltfe(bin_width,temperature,freq_dos,tdependence2_filename)
  write(*,*)
end subroutine

subroutine lte_2(structure,structure_sc,force_constants, &
   & no_kspace_lines,path, &
   & phonon_dispersion_curve_filename,high_symmetry_points_filename)
  use constants, only : dp
  use string_module
  use structure_module
  use min_images_module
  use file_module
  implicit none
  
  ! ----------------------------------------
  ! Inputs
  ! ----------------------------------------
  type(StructureData), intent(in) :: structure
  type(StructureData), intent(in) :: structure_sc
  real(dp),            intent(in) :: force_constants(:,:,:)
  integer,             intent(in) :: no_kspace_lines
  real(dp),            intent(in) :: path(:,:)
  
  ! ----------------------------------------
  ! filenames
  ! ----------------------------------------
  type(String), intent(in) :: phonon_dispersion_curve_filename
  type(String), intent(in) :: high_symmetry_points_filename
  
  ! ----------------------------------------
  ! previously global variables
  ! ----------------------------------------
  type(MinImages), allocatable :: delta_prim(:,:,:)
  
  integer :: i
  
  delta_prim = calculate_delta_prim(structure,structure_sc)

  call print_line('Number of lines in k-space to plot     : '// &
     & no_kspace_lines)
  
  if (no_kspace_lines<1) then
    call print_line('Need to supply more lines in k-space!')
    call err()
  endif
  
  write(*,*)'Points along walk in reciprocal space &
    &(Cartesian components in a.u.):'
  do i=0,no_kspace_lines
    write(*,'(3(" ",f16.8))')path(1:3,i)
  enddo
  write(*,*)'Have read in points for dispersion curve.'
  
  write(*,*)'A dispersion curve will be calculated.'
  write(*,*)'Calculating the requested dispersion curve.'
  call generate_dispersion(structure,structure_sc,&
     & delta_prim,force_constants,path,phonon_dispersion_curve_filename, &
     & high_symmetry_points_filename)
  write(*,*)'Done.  dispersion_curve.dat has been generated.  (Please &
    &view this file using XMGrace.)'
  write(*,*)
end subroutine

subroutine lte_3(structure,structure_sc,force_constants)
  use constants, only : dp
  use string_module
  use structure_module
  use min_images_module
  implicit none
  
  ! ----------------------------------------
  ! Inputs
  ! ----------------------------------------
  type(StructureData), intent(in) :: structure
  type(StructureData), intent(in) :: structure_sc
  real(dp),            intent(in) :: force_constants(:,:,:)
  
  ! ----------------------------------------
  ! previously global variables
  ! ----------------------------------------
  type(MinImages), allocatable :: delta_prim(:,:,:)
  
  delta_prim = calculate_delta_prim(structure,structure_sc)

  write(*,*)'The speed of sound will be calculated.'
  write(*,*)'Calculating the speed of sound.'
  call calculate_speed_sound(structure,structure_sc,force_constants, &
     & delta_prim)
  write(*,*)'Done.  Speed of sound calculated.'
  write(*,*)
end subroutine

!function lte_4(structure,structure_sc,force_constants,                   &
!   & freq_grids_filename,disp_patterns_filename,kdisp_patterns_filename, &
!   & pol_vec_filename) result(output)
!  use constants, only : dp
!  use string_module
!  use structure_module
!  implicit none
!  
!  ! Inputs.
!  type(StructureData), intent(in) :: structure
!  type(StructureData), intent(in) :: structure_sc
!  real(dp),            intent(in) :: force_constants(:,:,:)
!  
!  ! filenames.
!  type(String), intent(in) :: freq_grids_filename
!  type(String), intent(in) :: disp_patterns_filename
!  type(String), intent(in) :: kdisp_patterns_filename
!  type(String), intent(in) :: pol_vec_filename
!  
!  ! Output.
!  type(LteReturn) :: output
!  
!  ! ----------------------------------------
!  ! previously global variables
!  ! ----------------------------------------
!  output = evaluate_freqs_on_grid(structure,structure_sc,force_constants, &
!     & freq_grids_filename,disp_patterns_filename, &
!     & kdisp_patterns_filename,pol_vec_filename)
!end function

subroutine fourier_interpolation(dyn_mats_ibz,structure,grid,temperature, &
   & kpoints_grid, &
   & path,atom_symmetry_group,   &
   & phonon_dispersion_curve_filename,high_symmetry_points_filename,        &
   & free_energy_filename,freq_dos_filename)
  use constants,  only : dp
  use linear_algebra
  use file_module
  use structure_module
  use string_module
  use supercell_module
  use group_module
  use min_images_module
  use construct_supercell_module
  use kpoints_module
  implicit none
  
  ! filenames
  complex(dp),         intent(in) :: dyn_mats_ibz(:,:,:)
  type(StructureData), intent(in) :: structure
  integer,             intent(in) :: grid(3)
  real(dp),            intent(in) :: temperature
  type(KpointsGrid),   intent(in) :: kpoints_grid
  real(dp),            intent(in) :: path(:,:)
  type(Group),         intent(in) :: atom_symmetry_group(:)
  type(String),        intent(in) :: phonon_dispersion_curve_filename
  type(String),        intent(in) :: high_symmetry_points_filename
  type(String),        intent(in) :: free_energy_filename
  type(String),        intent(in) :: freq_dos_filename
  
  ! variables
  real(dp), allocatable :: rotations_cart(:,:,:)
  
  type(MinImages), allocatable :: delta_prim(:,:,:)
  real(dp),        allocatable :: force_consts(:,:,:)
  
  complex(dp), allocatable :: dyn_mats_grid(:,:,:)
  complex(dp), allocatable :: phase(:,:,:)
  
  INTEGER :: i_cell
  INTEGER :: i_grid
  
  REAL(dp) :: k_dot_r
  real(dp) :: exponent
  
  integer :: i,j,k
  integer :: atom_1,atom_2,atom_1p,atom_2p
  integer :: mode_1,mode_2,mode_1p,mode_2p
  
  ! Supercell data
  type(SupercellData) :: grid_supercell
  type(StructureData) :: structure_sc
  
  ! --------------------------------------------------
  ! Construct a supercell across the entire grid.
  ! --------------------------------------------------
  call new(grid_supercell,product(grid))
  
  grid_supercell%supercell(1,:) = (/ grid(1), 0      , 0       /)
  grid_supercell%supercell(2,:) = (/ 0      , grid(2), 0       /)
  grid_supercell%supercell(3,:) = (/ 0      , 0      , grid(3) /)
  
  grid_supercell%recip_supercell = invert_int(grid_supercell%supercell)
  do i=1,size(kpoints_grid)
    grid_supercell%gvectors(:,i) = kpoints_grid%kpoints(:,i) &
                               & * (grid_supercell%sc_size/grid)
  enddo
  
  structure_sc = construct_supercell(structure,grid_supercell)
  
  ! --------------------------------------------------
  ! Use symmetries to construct all dynamical matrices
  !   from the dynamical matrices of the IBZ.
  ! --------------------------------------------------
  
  ! Calculate the relative phases between atoms at each k-point.
  allocate(phase(structure%no_atoms,structure%no_atoms,structure_sc%sc_size))
  do i=1,structure_sc%sc_size
    do atom_1=1,structure%no_atoms
      do atom_2=1,structure%no_atoms
        ! Calculate k.dx
        exponent = dot_product( structure_sc%gvectors(:,i), &
                              &   matmul( structure%recip_lattice, &
                                         &   structure%atoms(:,atom_2) &
                                         & - structure%atoms(:,atom_1)) &
                              & / structure_sc%sc_size)
        ! Calculate exp(i.k.dx)
        phase(atom_2,atom_1,i) = cmplx(cos(exponent),sin(exponent),dp)
      enddo
    enddo
  enddo
  
  ! Construct dynamical matrices.
  allocate(dyn_mats_grid( structure%no_modes, &
                        & structure%no_modes, &
                        & structure_sc%sc_size))
  rotations_cart = calculate_cartesian_rotations(structure)
  do i=1,structure_sc%sc_size
    j = kpoints_grid%symmetry_ids(i)
    k = kpoints_grid%ibz_ids(i)
    
    ! Construct the element of the dynamical matrix from that in the IBZ.
    do atom_1=1,structure%no_atoms
      mode_1 = (atom_1-1)*3+1
      atom_1p = operate(atom_symmetry_group(j),atom_1)
      mode_1p = (atom_1p-1)*3+1
      do atom_2=1,structure%no_atoms
        mode_2 = (atom_2-1)*3+1
        atom_2p = operate(atom_symmetry_group(j),atom_2)
        mode_2p = (atom_2p-1)*3+1
        
        dyn_mats_grid(mode_2p:mode_2p+2,mode_1p:mode_1p+2,i) =    &
           & matmul(matmul(                                       &
           &    rotations_cart(:,:,j),                            &
           &    dyn_mats_ibz(mode_2:mode_2+2,mode_1:mode_1+2,k)), &
           &    transpose(rotations_cart(:,:,j)))                 &
           & * phase(atom_2p,atom_2,i)*conjg(phase(atom_1p,atom_1,i))
      enddo
    enddo
    
    ! Apply time reversal symmetry if required.
    if (structure_sc%paired_gvec(i) == i) then
      dyn_mats_grid(:,:,i) = cmplx(real(dyn_mats_grid(:,:,i)), 0.0_dp, dp)
    endif
  enddo
  
  ! --------------------------------------------------
  ! Construct the matrix of force constants
  ! --------------------------------------------------
  allocate(force_consts( structure%no_modes, &
                       & structure%no_modes, &
                       & structure_sc%sc_size))
  force_consts=0.0_dp
  
  do i_cell=1,structure_sc%sc_size
    do i_grid=1,structure_sc%sc_size
      k_dot_r = dot_product(matmul( structure_sc%gvectors(:,i_grid), &
                                  & structure_sc%recip_supercell),   &
                                  & structure_sc%gvectors(:,i_cell))
      force_consts(:,:,i_cell) = force_consts(:,:,i_cell) &
                             & + real( dyn_mats_grid(:,:,i_grid) &
                             &       * cmplx(cos(k_dot_r),sin(k_dot_r),dp))
    enddo
  enddo
  
  do atom_1=1,structure%no_atoms
    mode_1 = (atom_1-1)*3+1
    do atom_2=1,structure%no_atoms
      mode_2 = (atom_2-1)*3+1
      force_consts(mode_2:mode_2+2,mode_1:mode_1+2,:) = &
         &   force_consts(mode_2:mode_2+2,mode_1:mode_1+2,:) &
         & / structure_sc%sc_size
    enddo
  enddo
  
  ! --------------------------------------------------
  ! Calculate minimum image distances.
  ! --------------------------------------------------
  allocate(delta_prim( structure%no_atoms, &
                     & structure%no_atoms, &
                     & structure_sc%no_modes))
  delta_prim = calculate_delta_prim(structure,structure_sc)
  
  ! --------------------------------------------------
  ! Generate dispersion and density of states.
  ! --------------------------------------------------
  call generate_dispersion(structure,structure_sc,&
     & delta_prim,force_consts,path,phonon_dispersion_curve_filename, &
     & high_symmetry_points_filename)
  
  call generate_dos(structure,structure_sc,delta_prim, &
     & force_consts,temperature,free_energy_filename,freq_dos_filename)
end subroutine
end module
