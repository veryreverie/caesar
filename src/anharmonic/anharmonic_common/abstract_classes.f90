! ======================================================================
! Four abstract classes.
!    - SubspaceBasis defines the basis of states spanning a subspace.
!    - SubspaceState defines a specific state, in terms of the basis.
!    - SubspaceStates defines a set of states, again in terms of the basis.
!    - PotentialData defines a potential.
! ======================================================================
! The intent is that SubspaceBasis is mostly unchanging, and specific sets
!    of states are defined in terms of this basis.
! See the example module in potential_pointer.f90 for how to use the
!    PotentialData type.
module abstract_classes_module
  use common_module
  
  use anharmonic_data_module
  use energy_spectrum_module
  use subspace_wavefunctions_module
  use subspace_wavefunctions_pointer_module
  implicit none
  
  private
  
  public :: SubspaceBasis
  public :: SubspaceState
  public :: SubspaceStates
  public :: PotentialData
  
  type, abstract, extends(Stringsable) :: SubspaceBasis
  contains
    procedure(initial_states_SubspaceBasis), public, deferred :: initial_states
    procedure(calculate_states_SubspaceBasis), public, deferred :: &
       & calculate_states
  end type
  
  type, abstract, extends(Stringsable) :: SubspaceState
    integer :: subspace_id
  end type
  
  type, abstract, extends(NoDefaultConstructor) :: SubspaceStates
  contains
    procedure(states_SubspaceStates),        public, deferred :: states
    procedure(spectra_SubspaceStates),       public, deferred :: spectra
    procedure(wavefunctions_SubspaceStates), public, deferred :: wavefunctions
    procedure(integrate_SubspaceStates),     public, deferred :: integrate
  end type
  
  type, abstract, extends(Stringsable) :: PotentialData
  contains
    ! Given all input data, generate the set of sampling points at which
    !    electronic structure calculations should be run in order to
    !    map out the potential.
    procedure(generate_sampling_points_PotentialData), public, deferred :: &
       & generate_sampling_points
    
    ! Given the same data as above, generate the potential.
    ! All electronic structure calculations generated by
    !    generate_sampling_points will all have been run.
    procedure(generate_potential_PotentialData), public, deferred :: &
       & generate_potential
    
    ! Return the energy at zero displacement, or set this energy to zero.
    procedure, public :: undisplaced_energy
    procedure(zero_energy_PotentialData), public, deferred :: zero_energy
    
    ! Return the energy and force at a given real or complex displacement.
    generic, public :: energy =>                    &
                     & energy_RealModeDisplacement, &
                     & energy_ComplexModeDisplacement
    generic, public :: force  =>                   &
                     & force_RealModeDisplacement, &
                     & force_ComplexModeDisplacement
    procedure(energy_RealModeDisplacement_PotentialData), public, &
       & deferred :: energy_RealModeDisplacement
    procedure(energy_ComplexModeDisplacement_PotentialData), public, &
       & deferred :: energy_ComplexModeDisplacement
    procedure(force_RealModeDisplacement_PotentialData), public, &
       & deferred :: force_RealModeDisplacement
    procedure(force_ComplexModeDisplacement_PotentialData), public, &
       & deferred :: force_ComplexModeDisplacement
    
    ! Evaluate <bra|potential|ket>.
    procedure(braket_PotentialData), public, deferred :: braket
    
    ! Evaluate <bra|potential|ket> in the case when <bra|potential|ket> is
    !    a scalar.
    procedure, public :: potential_energy
    
    ! Evaluate the thermal expectation of the potential for a set of harmonic
    !    states.
    procedure(harmonic_expectation_PotentialData), public, deferred :: &
       & harmonic_expectation
    
    ! Update the potential from previous iterations, either using damped
    !    iteration or a Pulay scheme.
    procedure(iterate_damped_PotentialData), public, deferred :: &
       & iterate_damped
    procedure(iterate_pulay_PotentialData), public, deferred :: &
       & iterate_pulay
  end type
  
  abstract interface
    impure elemental function initial_states_SubspaceBasis(this,subspace, &
       & anharmonic_data) result(output)
      import SubspaceBasis
      import DegenerateSubspace
      import AnharmonicData
      import SubspaceStates
      implicit none
      
      class(SubspaceBasis),     intent(in) :: this
      type(DegenerateSubspace), intent(in) :: subspace
      type(AnharmonicData),     intent(in) :: anharmonic_data
      class(SubspaceStates), allocatable   :: output
    end function
    
    impure elemental function calculate_states_SubspaceBasis(this,subspace, &
       & subspace_potential,anharmonic_data) result(output)
      import SubspaceBasis
      import DegenerateSubspace
      import PotentialData
      import AnharmonicData
      import SubspaceStates
      implicit none
      
      class(SubspaceBasis),     intent(in) :: this
      type(DegenerateSubspace), intent(in) :: subspace
      class(PotentialData),     intent(in) :: subspace_potential
      type(AnharmonicData),     intent(in) :: anharmonic_data
      class(SubspaceStates), allocatable   :: output
    end function
    
    function states_SubspaceStates(this,subspace,subspace_basis, &
       & anharmonic_data) result(output)
      import SubspaceStates
      import DegenerateSubspace
      import SubspaceBasis
      import AnharmonicData
      import SubspaceState
      implicit none
      
      class(SubspaceStates),    intent(in) :: this
      type(DegenerateSubspace), intent(in) :: subspace
      class(SubspaceBasis),     intent(in) :: subspace_basis
      type(AnharmonicData),     intent(in) :: anharmonic_data
      class(SubspaceState), allocatable    :: output(:)
    end function
    
    impure elemental function spectra_SubspaceStates(this,subspace, &
       & subspace_basis,anharmonic_data) result(output)
      import SubspaceStates
      import DegenerateSubspace
      import SubspaceBasis
      import AnharmonicData
      import EnergySpectra
      implicit none
      
      class(SubspaceStates),    intent(in) :: this
      type(DegenerateSubspace), intent(in) :: subspace
      class(SubspaceBasis),     intent(in) :: subspace_basis
      type(AnharmonicData),     intent(in) :: anharmonic_data
      type(EnergySpectra)                  :: output
    end function
    
    impure elemental function wavefunctions_SubspaceStates(this,subspace, &
       & subspace_basis,anharmonic_data) result(output)
      import SubspaceStates
      import DegenerateSubspace
      import SubspaceBasis
      import AnharmonicData
      import SubspaceWavefunctions
      implicit none
      
      class(SubspaceStates),    intent(in)      :: this
      type(DegenerateSubspace), intent(in)      :: subspace
      class(SubspaceBasis),     intent(in)      :: subspace_basis
      type(AnharmonicData),     intent(in)      :: anharmonic_data
      class(SubspaceWavefunctions), allocatable :: output
    end function
    
    impure elemental function integrate_SubspaceStates(this,potential, &
       & subspace,subspace_basis,anharmonic_data) result(output)
      import SubspaceStates
      import PotentialData
      import DegenerateSubspace
      import SubspaceBasis
      import AnharmonicData
      implicit none
      
      class(SubspaceStates),    intent(in) :: this
      class(PotentialData),     intent(in) :: potential
      type(DegenerateSubspace), intent(in) :: subspace
      class(SubspaceBasis),     intent(in) :: subspace_basis
      type(AnharmonicData),     intent(in) :: anharmonic_data
      class(PotentialData), allocatable    :: output
    end function
    
    subroutine generate_sampling_points_PotentialData(this,anharmonic_data, &
       & sampling_points_dir,calculation_writer,logfile)
      import PotentialData
      import AnharmonicData
      import String
      import CalculationWriter
      import OFile
      implicit none
      
      class(PotentialData),    intent(inout) :: this
      type(AnharmonicData),    intent(in)    :: anharmonic_data
      type(String),            intent(in)    :: sampling_points_dir
      type(CalculationWriter), intent(inout) :: calculation_writer
      type(OFile),             intent(inout) :: logfile
    end subroutine
    
    subroutine generate_potential_PotentialData(this,anharmonic_data,        &
       & weighted_energy_force_ratio,sampling_points_dir,calculation_reader, &
       & logfile)
      import dp
      import PotentialData
      import AnharmonicData
      import String
      import CalculationReader
      import OFile
      implicit none
      
      class(PotentialData),    intent(inout) :: this
      type(AnharmonicData),    intent(in)    :: anharmonic_data
      real(dp),                intent(in)    :: weighted_energy_force_ratio
      type(String),            intent(in)    :: sampling_points_dir
      type(CalculationReader), intent(inout) :: calculation_reader
      type(OFile),             intent(inout) :: logfile
    end subroutine
    
    impure elemental subroutine zero_energy_PotentialData(this)
      import PotentialData
      implicit none
      
      class(PotentialData), intent(inout) :: this
    end subroutine
    
    impure elemental function energy_RealModeDisplacement_PotentialData(this, &
       & displacement) result(output)
      import dp
      import PotentialData
      import RealModeDisplacement
      implicit none
      
      class(PotentialData),       intent(in) :: this
      type(RealModeDisplacement), intent(in) :: displacement
      real(dp)                               :: output
    end function
    
    impure elemental function energy_ComplexModeDisplacement_PotentialData( &
       & this,displacement) result(output)
      import dp
      import PotentialData
      import ComplexModeDisplacement
      implicit none
      
      class(PotentialData),          intent(in) :: this
      type(ComplexModeDisplacement), intent(in) :: displacement
      complex(dp)                               :: output
    end function
    
    impure elemental function force_RealModeDisplacement_PotentialData(this, &
       & displacement) result(output)
      import PotentialData
      import RealModeDisplacement
      import RealModeForce
      implicit none
      
      class(PotentialData),       intent(in) :: this
      type(RealModeDisplacement), intent(in) :: displacement
      type(RealModeForce)                    :: output
    end function
    
    impure elemental function force_ComplexModeDisplacement_PotentialData( &
       & this,displacement) result(output)
      import PotentialData
      import ComplexModeDisplacement
      import ComplexModeForce
      implicit none
      
      class(PotentialData),          intent(in) :: this
      type(ComplexModeDisplacement), intent(in) :: displacement
      type(ComplexModeForce)                    :: output
    end function
    
    function braket_PotentialData(this,bra,ket,subspace,anharmonic_data) &
       & result(output)
      import PotentialData
      import SubspaceState
      import DegenerateSubspace
      import AnharmonicData
      implicit none
      
      class(PotentialData),     intent(in) :: this
      class(SubspaceState),     intent(in) :: bra
      class(SubspaceState),     intent(in) :: ket
      type(DegenerateSubspace), intent(in) :: subspace
      type(AnharmonicData),     intent(in) :: anharmonic_data
      class(PotentialData), allocatable    :: output
    end function
    
    function harmonic_expectation_PotentialData(this,frequency, &
       & thermal_energy,no_states,subspace,anharmonic_data) result(output)
      import PotentialData
      import dp
      import DegenerateSubspace
      import AnharmonicData
      implicit none
      
      class(PotentialData),     intent(in) :: this
      real(dp),                 intent(in) :: frequency
      real(dp),                 intent(in) :: thermal_energy
      integer,                  intent(in) :: no_states
      type(DegenerateSubspace), intent(in) :: subspace
      type(AnharmonicData),     intent(in) :: anharmonic_data
      real(dp)                             :: output
    end function
    
    impure elemental function iterate_damped_PotentialData(this, &
       & new_potential,damping,anharmonic_data) result(output)
      import PotentialData
      import dp
      import AnharmonicData
      implicit none
      
      class(PotentialData), intent(in)  :: this
      class(PotentialData), intent(in)  :: new_potential
      real(dp),             intent(in)  :: damping
      type(AnharmonicData), intent(in)  :: anharmonic_data
      class(PotentialData), allocatable :: output
    end function
    
    function iterate_pulay_PotentialData(this,input_potentials, &
       & output_potentials,anharmonic_data) result(output)
      import PotentialData
      import AnharmonicData
      implicit none
      
      class(PotentialData), intent(in)  :: this
      class(PotentialData), intent(in)  :: input_potentials(:)
      class(PotentialData), intent(in)  :: output_potentials(:)
      type(AnharmonicData), intent(in)  :: anharmonic_data
      class(PotentialData), allocatable :: output
    end function
  end interface
contains

function undisplaced_energy(this) result(output)
  implicit none
  
  class(PotentialData), intent(in) :: this
  real(dp)                         :: output
  
  type(RealModeDisplacement) :: zero_displacement
  
  zero_displacement = RealModeDisplacement([RealSingleDisplacement::])
  
  output = this%energy(zero_displacement)
end function

function potential_energy(this,bra,ket,subspace,anharmonic_data) result(output)
  implicit none
  
  class(PotentialData),     intent(in) :: this
  class(SubspaceState),     intent(in) :: bra
  class(SubspaceState),     intent(in) :: ket
  type(DegenerateSubspace), intent(in) :: subspace
  type(AnharmonicData),     intent(in) :: anharmonic_data
  real(dp)                             :: output
  
  class(PotentialData), allocatable :: potential
  
  integer :: ialloc
  
  allocate( potential, source=this%braket(bra,ket,subspace,anharmonic_data), &
          & stat=ialloc); call err(ialloc)
  output = potential%undisplaced_energy()
end function
end module
