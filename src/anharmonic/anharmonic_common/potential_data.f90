! ======================================================================
! Defines the PotentialData type and the PotentialPointer.
! This type extends PotentialBase with methods for constructing
!    and interpolating the potential.
! ======================================================================
module potential_data_module
  use common_module
  
  use subspace_coupling_module
  use anharmonic_data_module
  use subspace_state_module
  use subspace_braket_module
  use basis_state_module
  use basis_states_module
  use abstract_classes_module
  use stress_data_module
  implicit none
  
  public :: PotentialData
  public :: PotentialPointer
  
  type, abstract, extends(PotentialBase) :: PotentialData
  contains
    procedure(representation_PotentialData), public, deferred, nopass :: &
       & representation
    procedure, public :: startup => startup_PotentialData
    
    ! Given all input data, generate the set of sampling points at which
    !    electronic structure calculations should be run in order to
    !    map out the potential.
    procedure(generate_sampling_points_PotentialData), public, deferred :: &
       & generate_sampling_points
    
    ! Given the same data as above, generate the potential.
    ! All electronic structure calculations generated by
    !    generate_sampling_points will all have been run.
    procedure(generate_potential_PotentialData), public, deferred :: &
       & generate_potential
    
    ! Given the same data as above, and assuming that generate_potential
    !    has already been called, generate a StressData.
    procedure(generate_stress_PotentialData), public, deferred :: &
       & generate_stress
    
    ! Interpolation of the potential.
    procedure, public :: can_be_interpolated => &
                       & can_be_interpolated_PotentialData
    procedure, public :: interpolate => &
                       & interpolate_PotentialData
    procedure, public :: calculate_dynamical_matrices => &
                       & calculate_dynamical_matrices_PotentialData
    procedure, public :: energy_correction => &
                       & energy_correction_PotentialData
    
    ! Finalise the subspace potential.
    procedure, public :: optimise_subspace_potential => &
                       & optimise_subspace_potential_PotentialData
    
    ! Convert the potential to and from a set of real coefficients.
    ! Required for Pulay scheme.
    procedure(coefficients_PotentialData), public, deferred :: &
       & coefficients
    procedure(set_coefficients_PotentialData), public, deferred :: &
       & set_coefficients
    procedure(all_basis_functions_PotentialData), public, deferred :: &
       & all_basis_functions
    procedure(variable_basis_functions_PotentialData), public, deferred :: &
       & variable_basis_functions
  end type
  
  type, extends(PotentialData) :: PotentialPointer
    type(String),                      private :: representation_
    class(PotentialData), allocatable, private :: potential_
  contains
    procedure, private :: check => check_PotentialPointer
    
    procedure, public, nopass :: representation => &
                               & representation_PotentialPointer
    
    procedure, public :: potential => potential_potentialPointer
    
    procedure, public :: energy_RealModeDisplacement => &
                       & energy_RealModeDisplacement_PotentialPointer
    procedure, public :: energy_ComplexModeDisplacement => &
                       & energy_ComplexModeDisplacement_PotentialPointer
    procedure, public :: force_RealModeDisplacement => &
                       & force_RealModeDisplacement_PotentialPointer
    procedure, public :: force_ComplexModeDisplacement => &
                       & force_ComplexModeDisplacement_PotentialPointer
    
    procedure, public :: braket_SubspaceBraKet  => &
                       & braket_SubspaceBraKet_PotentialPointer
    procedure, public :: braket_BasisState  => &
                       & braket_BasisState_PotentialPointer
    procedure, public :: braket_BasisStates => &
                       & braket_BasisStates_PotentialPointer
    
    procedure, public :: harmonic_expectation => &
                       & harmonic_expectation_PotentialPointer
    
    procedure, public :: potential_energy_SubspaceBraKet => &
                       & potential_energy_SubspaceBraKet_PotentialPointer
    procedure, public :: potential_energy_BasisState => &
                       & potential_energy_BasisState_PotentialPointer
    
    procedure, public :: generate_sampling_points => &
       & generate_sampling_points_PotentialPointer
    procedure, public :: generate_potential => &
       & generate_potential_PotentialPointer
    procedure, public :: generate_stress => &
       & generate_stress_PotentialPointer
    
    procedure, public :: zero_energy => zero_energy_PotentialPointer
    procedure, public :: add_constant => add_constant_PotentialPointer
    
    procedure, public :: optimise_subspace_potential => &
                       & optimise_subspace_potential_PotentialPointer
    
    procedure, public :: coefficients => &
                       & coefficients_PotentialPointer
    procedure, public :: set_coefficients => &
                       & set_coefficients_PotentialPointer
    procedure, public :: all_basis_functions => &
                       & all_basis_functions_PotentialPointer
    procedure, public :: variable_basis_functions => &
                       & variable_basis_functions_PotentialPointer
    
    procedure, public :: can_be_interpolated => &
                       & can_be_interpolated_PotentialPointer
    procedure, public :: interpolate => &
                       & interpolate_PotentialPointer
    procedure, public :: calculate_dynamical_matrices => &
                       & calculate_dynamical_matrices_PotentialPointer
    procedure, public :: energy_correction => &
                       & energy_correction_PotentialPointer
    
    ! I/O.
    procedure, public :: read  => read_PotentialPointer
    procedure, public :: write => write_PotentialPointer
  end type
  
  ! An array of all types which extend PotentialData.
  ! This array will be filled in by startup routines.
  type(PotentialPointer), allocatable :: TYPES_PotentialData(:)
  
  interface PotentialPointer
    module procedure new_PotentialPointer
    module procedure new_PotentialPointer_Strings
    module procedure new_PotentialPointer_StringArray
  end interface
  
  abstract interface
    ! PotentialData procedures.
    impure elemental function representation_PotentialData() result(output)
      import String
      implicit none
      
      type(String) :: output
    end function
    
    subroutine generate_sampling_points_PotentialData(this,anharmonic_data, &
       & use_forces,energy_to_force_ratio,use_hessians,calculate_stress,    &
       & sampling_points_dir,calculation_writer,logfile)
      import PotentialData
      import AnharmonicData
      import dp
      import String
      import CalculationWriter
      import OFile
      implicit none
      
      class(PotentialData),    intent(inout) :: this
      type(AnharmonicData),    intent(in)    :: anharmonic_data
      logical,                 intent(in)    :: use_forces
      real(dp),                intent(in)    :: energy_to_force_ratio
      logical,                 intent(in)    :: use_hessians
      logical,                 intent(in)    :: calculate_stress
      type(String),            intent(in)    :: sampling_points_dir
      type(CalculationWriter), intent(inout) :: calculation_writer
      type(OFile),             intent(inout) :: logfile
    end subroutine
    
    subroutine generate_potential_PotentialData(this,anharmonic_data,        &
       & weighted_energy_force_ratio,sampling_points_dir,calculation_reader, &
       & logfile)
      import dp
      import PotentialData
      import AnharmonicData
      import String
      import CalculationReader
      import OFile
      implicit none
      
      class(PotentialData),    intent(inout) :: this
      type(AnharmonicData),    intent(in)    :: anharmonic_data
      real(dp),                intent(in)    :: weighted_energy_force_ratio
      type(String),            intent(in)    :: sampling_points_dir
      type(CalculationReader), intent(inout) :: calculation_reader
      type(OFile),             intent(inout) :: logfile
    end subroutine
    
    function generate_stress_PotentialData(this,anharmonic_data, &
       & sampling_points_dir,stress_expansion_order,             &
       & stress_subspace_coupling,vscf_basis_functions_only,     &
       & calculation_reader,logfile) result(output)
      import dp
      import PotentialData
      import AnharmonicData
      import String
      import SubspaceCoupling
      import CalculationReader
      import OFile
      import StressPointer
      implicit none
      
      class(PotentialData),    intent(in)    :: this
      type(AnharmonicData),    intent(in)    :: anharmonic_data
      type(String),            intent(in)    :: sampling_points_dir
      integer,                 intent(in)    :: stress_expansion_order
      type(SubspaceCoupling),  intent(in)    :: stress_subspace_coupling(:)
      logical,                 intent(in)    :: vscf_basis_functions_only
      type(CalculationReader), intent(inout) :: calculation_reader
      type(OFile),             intent(inout) :: logfile
      type(StressPointer)                    :: output
    end function
    
    function coefficients_PotentialData(this,anharmonic_data) &
       & result(output)
      import PotentialData
      import AnharmonicData
      import dp
      implicit none
      
      class(PotentialData), intent(in) :: this
      type(AnharmonicData), intent(in) :: anharmonic_data
      real(dp), allocatable            :: output(:)
    end function
    
    subroutine set_coefficients_PotentialData(this,coefficients, &
       & anharmonic_data)
      import PotentialData
      import AnharmonicData
      import dp
      implicit none
      
      class(PotentialData), intent(inout) :: this
      real(dp),             intent(in)    :: coefficients(:)
      type(AnharmonicData), intent(in)    :: anharmonic_data
    end subroutine
    
    function all_basis_functions_PotentialData(this,anharmonic_data) &
       & result(output)
      import PotentialData
      import AnharmonicData
      import PotentialBasePointer
      implicit none
      
      class(PotentialData), intent(in)        :: this
      type(AnharmonicData), intent(in)        :: anharmonic_data
      type(PotentialBasePointer), allocatable :: output(:)
    end function
    
    function variable_basis_functions_PotentialData(this,anharmonic_data) &
       & result(output)
      import PotentialData
      import AnharmonicData
      import PotentialBasePointer
      implicit none
      
      class(PotentialData), intent(in)        :: this
      type(AnharmonicData), intent(in)        :: anharmonic_data
      type(PotentialBasePointer), allocatable :: output(:)
    end function
  end interface
contains

subroutine startup_PotentialData(this)
  implicit none
  
  class(PotentialData), intent(in) :: this
  
  type(PotentialBasePointer) :: base
  
  integer :: i
  
  ! TODO: this doesn't work. It calls the startup() method for
  !    PotentialBasePointer only.
  base = PotentialBasePointer(this)
  call base%startup()
  
  if (.not.allocated(TYPES_PotentialData)) then
    TYPES_PotentialData = [PotentialPointer(this)]
  elseif (.not.any([(                                            &
     & this%representation()                                     &
     &    == TYPES_PotentialData(i)%potential_%representation(), &
     & i=1,                                                      &
     & size(TYPES_PotentialData)                                 )])) then
    TYPES_PotentialData = [TYPES_PotentialData, PotentialPointer(this)]
  endif
end subroutine

! Construct a PotentialPointer from any type which extends PotentialData.
impure elemental function new_PotentialPointer(potential) result(this)
  implicit none
  
  class(PotentialData), intent(in) :: potential
  type(PotentialPointer)           :: this
  
  integer :: ialloc
  
  select type(potential); type is(PotentialPointer)
    this = potential
  class default
    this%representation_ = potential%representation()
    allocate( this%potential_, source=potential, &
            & stat=ialloc); call err(ialloc)
  end select
end function

! Checks that the pointer has been allocated before it is used.
impure elemental subroutine check_PotentialPointer(this)
  implicit none
  
  class(PotentialPointer), intent(in) :: this
  
  if (.not. allocated(this%potential_)) then
    call print_line(CODE_ERROR//': Trying to use a PotentialPointer before &
       &it has been allocated.')
    call err()
  endif
end subroutine

! Type representation.
impure elemental function representation_PotentialPointer() result(output)
  implicit none
  
  type(String) :: output
  
  output = 'pointer'
end function

! Return the stored potential.
impure function potential_PotentialPointer(this) result(output)
  implicit none
  
  class(PotentialPointer), intent(in) :: this
  class(PotentialData), allocatable   :: output
  
  call this%check()
  
  output = this%potential_
end function

! Wrappers for all of PotentialData's methods.
subroutine generate_sampling_points_PotentialPointer(this,anharmonic_data, &
   & use_forces,energy_to_force_ratio,use_hessians,calculate_stress,       &
   & sampling_points_dir,calculation_writer,logfile)
  implicit none
  
  class(PotentialPointer), intent(inout) :: this
  type(AnharmonicData),    intent(in)    :: anharmonic_data
  logical,                 intent(in)    :: use_forces
  real(dp),                intent(in)    :: energy_to_force_ratio
  logical,                 intent(in)    :: use_hessians
  logical,                 intent(in)    :: calculate_stress
  type(String),            intent(in)    :: sampling_points_dir
  type(CalculationWriter), intent(inout) :: calculation_writer
  type(OFile),             intent(inout) :: logfile
  
  call this%check()
  
  call this%potential_%generate_sampling_points( anharmonic_data,       &
                                               & use_forces,            &
                                               & energy_to_force_ratio, &
                                               & use_hessians,          &
                                               & calculate_stress,      &
                                               & sampling_points_dir,   &
                                               & calculation_writer,    &
                                               & logfile                )
end subroutine

subroutine generate_potential_PotentialPointer(this,anharmonic_data,     &
   & weighted_energy_force_ratio,sampling_points_dir,calculation_reader, &
   & logfile)
  implicit none
  
  class(PotentialPointer), intent(inout) :: this
  type(AnharmonicData),    intent(in)    :: anharmonic_data
  real(dp),                intent(in)    :: weighted_energy_force_ratio
  type(String),            intent(in)    :: sampling_points_dir
  type(CalculationReader), intent(inout) :: calculation_reader
  type(OFile),             intent(inout) :: logfile
  
  call this%check()
  
  call this%potential_%generate_potential( anharmonic_data,              &
                                         & weighted_energy_force_ratio,  &
                                         & sampling_points_dir,          &
                                         & calculation_reader,           &
                                         & logfile                       )
end subroutine

function generate_stress_PotentialPointer(this,anharmonic_data,           &
   & sampling_points_dir,stress_expansion_order,stress_subspace_coupling, &
   & vscf_basis_functions_only,calculation_reader,logfile) result(output)
  implicit none
  
  class(PotentialPointer), intent(in)    :: this
  type(AnharmonicData),    intent(in)    :: anharmonic_data
  type(String),            intent(in)    :: sampling_points_dir
  integer,                 intent(in)    :: stress_expansion_order
  type(SubspaceCoupling),  intent(in)    :: stress_subspace_coupling(:)
  logical,                 intent(in)    :: vscf_basis_functions_only
  type(CalculationReader), intent(inout) :: calculation_reader
  type(OFile),             intent(inout) :: logfile
  type(StressPointer)                    :: output
  
  call this%check()
  
  output = this%potential_%generate_stress( anharmonic_data,           &
                                          & sampling_points_dir,       &
                                          & stress_expansion_order,    &
                                          & stress_subspace_coupling,  &
                                          & vscf_basis_functions_only, &
                                          & calculation_reader,        &
                                          & logfile                    )
end function

impure elemental subroutine zero_energy_PotentialPointer(this)
  implicit none
  
  class(PotentialPointer), intent(inout) :: this
  
  call this%check()
  
  call this%potential_%zero_energy()
end subroutine

impure elemental subroutine add_constant_PotentialPointer(this,input)
  implicit none
  
  class(PotentialPointer), intent(inout) :: this
  real(dp),                intent(in)    :: input
  
  call this%check()
  
  call this%potential_%add_constant(input)
end subroutine

subroutine optimise_subspace_potential_PotentialPointer(this,subspace, &
   & subspace_basis,old_subspace_potential,anharmonic_data)
  implicit none
  
  class(PotentialPointer),  intent(inout)        :: this
  type(DegenerateSubspace), intent(in)           :: subspace
  class(SubspaceBasis),     intent(in)           :: subspace_basis
  class(PotentialData),     intent(in), optional :: old_subspace_potential
  type(AnharmonicData),     intent(in)           :: anharmonic_data
  
  call this%check()
  
  call this%potential_%optimise_subspace_potential( subspace,               &
                                                  & subspace_basis,         &
                                                  & old_subspace_potential, &
                                                  & anharmonic_data         )
end subroutine

impure elemental function energy_RealModeDisplacement_PotentialPointer(this, &
   & displacement) result(output)
  implicit none
  
  class(PotentialPointer),    intent(in) :: this
  type(RealModeDisplacement), intent(in) :: displacement
  real(dp)                               :: output
  
  call this%check()
  
  output = this%potential_%energy(displacement)
end function

impure elemental function energy_ComplexModeDisplacement_PotentialPointer( &
   & this,displacement) result(output)
  implicit none
  
  class(PotentialPointer),       intent(in) :: this
  type(ComplexModeDisplacement), intent(in) :: displacement
  complex(dp)                               :: output
  
  call this%check()
  
  output = this%potential_%energy(displacement)
end function

impure elemental function force_RealModeDisplacement_PotentialPointer(this, &
   & displacement) result(output)
  implicit none
  
  class(PotentialPointer),    intent(in) :: this
  type(RealModeDisplacement), intent(in) :: displacement
  type(RealModeForce)                    :: output
  
  call this%check()
  
  output = this%potential_%force(displacement)
end function

impure elemental function force_ComplexModeDisplacement_PotentialPointer( &
   & this,displacement) result(output)
  implicit none
  
  class(PotentialPointer),       intent(in) :: this
  type(ComplexModeDisplacement), intent(in) :: displacement
  type(ComplexModeForce)                    :: output
  
  call this%check()
  
  output = this%potential_%force(displacement)
end function

impure elemental subroutine braket_SubspaceBraKet_PotentialPointer(this, &
   & braket,whole_subspace,anharmonic_data) 
  implicit none
  
  class(PotentialPointer), intent(inout)        :: this
  class(SubspaceBraKet),   intent(in)           :: braket
  logical,                 intent(in), optional :: whole_subspace
  type(AnharmonicData),    intent(in)           :: anharmonic_data
  
  call this%check()
  
  call this%potential_%braket(braket,whole_subspace,anharmonic_data)
end subroutine

impure elemental subroutine braket_BasisState_PotentialPointer(this,bra,ket, &
   & subspace,subspace_basis,whole_subspace,anharmonic_data) 
  implicit none
  
  class(PotentialPointer),  intent(inout)        :: this
  class(BasisState),        intent(in)           :: bra
  class(BasisState),        intent(in), optional :: ket
  type(DegenerateSubspace), intent(in)           :: subspace
  class(SubspaceBasis),     intent(in)           :: subspace_basis
  logical,                  intent(in), optional :: whole_subspace
  type(AnharmonicData),     intent(in)           :: anharmonic_data
  
  call this%check()
  
  call this%potential_%braket( bra,            &
                             & ket,            &
                             & subspace,       &
                             & subspace_basis, &
                             & whole_subspace, &
                             & anharmonic_data )
end subroutine

impure elemental subroutine braket_BasisStates_PotentialPointer(this,states, &
   & subspace,subspace_basis,whole_subspace,anharmonic_data) 
  implicit none
  
  class(PotentialPointer),  intent(inout)        :: this
  class(BasisStates),       intent(inout)        :: states
  type(DegenerateSubspace), intent(in)           :: subspace
  class(SubspaceBasis),     intent(in)           :: subspace_basis
  logical,                  intent(in), optional :: whole_subspace
  type(AnharmonicData),     intent(in)           :: anharmonic_data
  
  call this%check()
  
  call this%potential_%braket( states,         &
                             & subspace,       &
                             & subspace_basis, &
                             & whole_subspace, &
                             & anharmonic_data )
end subroutine

impure elemental function harmonic_expectation_PotentialPointer(this, &
   & frequency,thermal_energy,supercell_size,anharmonic_data) result(output)
  implicit none
  
  class(PotentialPointer), intent(in) :: this
  real(dp),                intent(in) :: frequency
  real(dp),                intent(in) :: thermal_energy
  integer,                 intent(in) :: supercell_size
  type(AnharmonicData),    intent(in) :: anharmonic_data
  real(dp)                            :: output
  
  call this%check()
  
  output = this%potential_%harmonic_expectation( frequency,      &
                                               & thermal_energy, &
                                               & supercell_size, &
                                               & anharmonic_data )
end function

recursive function potential_energy_SubspaceBraKet_PotentialPointer(this, &
   & braket,anharmonic_data) result(output) 
  implicit none
  
  class(PotentialPointer), intent(in) :: this
  class(SubspaceBraKet),   intent(in) :: braket
  type(AnharmonicData),    intent(in) :: anharmonic_data
  real(dp)                            :: output
  
  call this%check()
  
  output = this%potential_%potential_energy(braket, anharmonic_data)
end function

recursive function potential_energy_BasisState_PotentialPointer(this,bra,ket, &
   & subspace,subspace_basis,anharmonic_data) result(output) 
  implicit none
  
  class(PotentialPointer),  intent(in)           :: this
  class(BasisState),        intent(in)           :: bra
  class(BasisState),        intent(in), optional :: ket
  type(DegenerateSubspace), intent(in)           :: subspace
  class(SubspaceBasis),     intent(in)           :: subspace_basis
  type(AnharmonicData),     intent(in)           :: anharmonic_data
  real(dp)                                       :: output
  
  call this%check()
  
  output = this%potential_%potential_energy( bra,            &
                                           & ket,            &
                                           & subspace,       &
                                           & subspace_basis, &
                                           & anharmonic_data )
end function

function coefficients_PotentialPointer(this,anharmonic_data) &
   & result(output)
  implicit none
  
  class(PotentialPointer), intent(in) :: this
  type(AnharmonicData),    intent(in) :: anharmonic_data
  real(dp), allocatable               :: output(:)
  
  call this%check()
  
  output = this%potential_%coefficients(anharmonic_data)
end function

subroutine set_coefficients_PotentialPointer(this,coefficients, &
   & anharmonic_data)
  implicit none
  
  class(PotentialPointer), intent(inout) :: this
  real(dp),                intent(in)    :: coefficients(:)
  type(AnharmonicData),    intent(in)    :: anharmonic_data
  
  call this%check()
  
  call this%potential_%set_coefficients( coefficients,   &
                                       & anharmonic_data )
end subroutine

function all_basis_functions_PotentialPointer(this,anharmonic_data) &
   & result(output)
  implicit none
  
  class(PotentialPointer), intent(in)     :: this
  type(AnharmonicData),    intent(in)     :: anharmonic_data
  type(PotentialBasePointer), allocatable :: output(:)
  
  call this%check()
  
  output = this%potential_%all_basis_functions(anharmonic_data)
end function

function variable_basis_functions_PotentialPointer(this,anharmonic_data) &
   & result(output)
  implicit none
  
  class(PotentialPointer), intent(in)     :: this
  type(AnharmonicData),    intent(in)     :: anharmonic_data
  type(PotentialBasePointer), allocatable :: output(:)
  
  call this%check()
  
  output = this%potential_%variable_basis_functions(anharmonic_data)
end function

function can_be_interpolated_PotentialPointer(this) result(output)
  implicit none
  
  class(PotentialPointer), intent(in) :: this
  logical                             :: output
  
  call this%check()
  
  output = this%potential_%can_be_interpolated()
end function

function interpolate_PotentialPointer(this,qpoint,subspace,subspace_modes, &
   & anharmonic_min_images, thermal_energy,subspaces,subspace_bases,       &
   & subspace_states,anharmonic_data) result(output)
  implicit none
  
  class(PotentialPointer),  intent(in)    :: this
  type(RealVector),         intent(in)    :: qpoint
  type(DegenerateSubspace), intent(in)    :: subspace
  type(ComplexMode),        intent(in)    :: subspace_modes(:)
  type(MinImages),          intent(in)    :: anharmonic_min_images(:,:)
  real(dp),                 intent(in)    :: thermal_energy
  type(DegenerateSubspace), intent(in)    :: subspaces(:)
  class(SubspaceBasis),     intent(in)    :: subspace_bases(:)
  class(BasisStates),       intent(inout) :: subspace_states(:)
  type(AnharmonicData),     intent(in)    :: anharmonic_data
  type(PotentialPointer)                  :: output
  
  call this%check()
  
  output = this%potential_%interpolate( qpoint, &
                                      & subspace, &
                                      & subspace_modes, &
                                      & anharmonic_min_images, &
                                      & thermal_energy,      &
                                      & subspaces,           &
                                      & subspace_bases,      &
                                      & subspace_states,     &
                                      & anharmonic_data      )
end function

function calculate_dynamical_matrices_PotentialPointer(this,qpoints,          &
   & thermal_energy,subspaces,subspace_bases,subspace_states,anharmonic_data) &
   & result(output) 
  implicit none
  
  class(PotentialPointer),  intent(in)    :: this
  type(QpointData),         intent(in)    :: qpoints(:)
  real(dp),                 intent(in)    :: thermal_energy
  type(DegenerateSubspace), intent(in)    :: subspaces(:)
  class(SubspaceBasis),     intent(in)    :: subspace_bases(:)
  class(BasisStates),       intent(inout) :: subspace_states(:)
  type(AnharmonicData),     intent(in)    :: anharmonic_data
  type(DynamicalMatrix), allocatable      :: output(:)
  
  call this%check()
  
  output = this%potential_%calculate_dynamical_matrices( qpoints,             &
                                                       & thermal_energy,      &
                                                       & subspaces,           &
                                                       & subspace_bases,      &
                                                       & subspace_states,     &
                                                       & anharmonic_data      )
end function

function energy_correction_PotentialPointer(this,subspaces,subspace_bases, &
   & subspace_states,anharmonic_data) result(output) 
  implicit none
  
  class(PotentialPointer),  intent(in)    :: this
  type(DegenerateSubspace), intent(in)    :: subspaces(:)
  class(SubspaceBasis),     intent(in)    :: subspace_bases(:)
  class(BasisStates),       intent(inout) :: subspace_states(:)
  type(AnharmonicData),     intent(in)    :: anharmonic_data
  real(dp)                                :: output
  
  call this%check()
  
  output = this%potential_%energy_correction( subspaces,       &
                                            & subspace_bases,  &
                                            & subspace_states, &
                                            & anharmonic_data  )
end function

! Concrete PotentialData methods.
function can_be_interpolated_PotentialData(this) result(output)
  implicit none
  
  class(PotentialData), intent(in) :: this
  logical                          :: output
  
  output = .false.
end function

function interpolate_PotentialData(this,qpoint,subspace,subspace_modes,  &
   & anharmonic_min_images,thermal_energy,subspaces,subspace_bases,      &
   & subspace_states,anharmonic_data) result(output)
  implicit none
  
  class(PotentialData),     intent(in)    :: this
  type(RealVector),         intent(in)    :: qpoint
  type(DegenerateSubspace), intent(in)    :: subspace
  type(ComplexMode),        intent(in)    :: subspace_modes(:)
  type(MinImages),          intent(in)    :: anharmonic_min_images(:,:)
  real(dp),                 intent(in)    :: thermal_energy
  type(DegenerateSubspace), intent(in)    :: subspaces(:)
  class(SubspaceBasis),     intent(in)    :: subspace_bases(:)
  class(BasisStates),       intent(inout) :: subspace_states(:)
  type(AnharmonicData),     intent(in)    :: anharmonic_data
  type(PotentialPointer)                  :: output
  
  ! This should be gated behind can_be_interpolated.
  call print_line(CODE_ERROR//': calculate_interpolated_thermodynamics not &
     &implemented for this potential.')
  call err()
end function

function calculate_dynamical_matrices_PotentialData(this,qpoints,             &
   & thermal_energy,subspaces,subspace_bases,subspace_states,anharmonic_data) &
   & result(output) 
  implicit none
  
  class(PotentialData),     intent(in)    :: this
  type(QpointData),         intent(in)    :: qpoints(:)
  real(dp),                 intent(in)    :: thermal_energy
  type(DegenerateSubspace), intent(in)    :: subspaces(:)
  class(SubspaceBasis),     intent(in)    :: subspace_bases(:)
  class(BasisStates),       intent(inout) :: subspace_states(:)
  type(AnharmonicData),     intent(in)    :: anharmonic_data
  type(DynamicalMatrix), allocatable      :: output(:)
  
  ! This should be gated behind can_be_interpolated.
  call print_line(CODE_ERROR//': calculate_dynamical_matrices not &
     &implemented for this potential.')
  call err()
end function

function energy_correction_PotentialData(this,subspaces,subspace_bases, &
   & subspace_states,anharmonic_data) result(output) 
  implicit none
  
  class(PotentialData),     intent(in)    :: this
  type(DegenerateSubspace), intent(in)    :: subspaces(:)
  class(SubspaceBasis),     intent(in)    :: subspace_bases(:)
  class(BasisStates),       intent(inout) :: subspace_states(:)
  type(AnharmonicData),     intent(in)    :: anharmonic_data
  real(dp)                                :: output
  
  ! This should be gated behind can_be_interpolated.
  call print_line(CODE_ERROR//': energy_correction not implemented for this &
     &potential.')
  call err()
end function

subroutine optimise_subspace_potential_PotentialData(this,subspace, &
   & subspace_basis,old_subspace_potential,anharmonic_data) 
  implicit none
  
  class(PotentialData),     intent(inout)        :: this
  type(DegenerateSubspace), intent(in)           :: subspace
  class(SubspaceBasis),     intent(in)           :: subspace_basis
  class(PotentialData),     intent(in), optional :: old_subspace_potential
  type(AnharmonicData),     intent(in)           :: anharmonic_data
  
  ! By default this doesn't do anything.
end subroutine

! I/O.
subroutine read_PotentialPointer(this,input)
  implicit none
  
  class(PotentialPointer), intent(out) :: this
  type(String),            intent(in)  :: input(:)
  
  type(String), allocatable :: line(:)
  
  type(String) :: representation
  
  integer :: i
  
  select type(this); type is(PotentialPointer)
    line = split_line(input(1))
    representation = line(3)
    
    ! Identify which type corresponds to the representation.
    i = first([(                                                             &
       & TYPES_PotentialData(i)%potential_%representation()==representation, &
       & i=1,                                                                &
       & size(TYPES_PotentialData)                                          )])
    
    ! Read the input into the element of the correct type,
    !    and copy that element into the output.
    call TYPES_PotentialData(i)%potential_%read(input(2:))
    this = PotentialPointer(TYPES_PotentialData(i))
  class default
    call err()
  end select
end subroutine

function write_PotentialPointer(this) result(output)
  implicit none
  
  class(PotentialPointer), intent(in) :: this
  type(String), allocatable           :: output(:)
  
  select type(this); type is(PotentialPointer)
    output = [ 'Potential representation: '//this%representation_, &
             & str(this%potential_)                                ]
  end select
end function

function new_PotentialPointer_Strings(input) result(this)
  implicit none
  
  type(String), intent(in) :: input(:)
  type(PotentialPointer)   :: this
  
  call this%read(input)
end function

impure elemental function new_PotentialPointer_StringArray(input) result(this)
  implicit none
  
  type(StringArray), intent(in) :: input
  type(PotentialPointer)        :: this
  
  this = PotentialPointer(str(input))
end function

end module
