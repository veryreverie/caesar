! ======================================================================
! Defines the PotentialData type and the PotentialPointer.
! This type extends PotentialBase with methods for constructing
!    and interpolating the potential.
! ======================================================================
module caesar_potential_data_module
  use caesar_common_module
  
  use caesar_subspace_coupling_module
  use caesar_anharmonic_data_module
  use caesar_subspace_state_module
  use caesar_subspace_braket_module
  use caesar_basis_state_module
  use caesar_basis_states_module
  use caesar_abstract_classes_module
  use caesar_stress_data_module
  implicit none
  
  public :: PotentialData
  public :: PotentialPointer
  
  type, abstract, extends(PotentialBase) :: PotentialData
  contains
    procedure(representation_PotentialData), public, deferred, nopass :: &
       & representation
    procedure, public :: startup => startup_PotentialData
    
    ! Given all input data, generate the set of sampling points at which
    !    electronic structure calculations should be run in order to
    !    map out the potential.
    procedure(generate_sampling_points_PotentialData), public, deferred :: &
       & generate_sampling_points
    
    ! Given the same data as above, generate the potential.
    ! All electronic structure calculations generated by
    !    generate_sampling_points will all have been run.
    procedure(generate_potential_PotentialData), public, deferred :: &
       & generate_potential
    
    ! Given the same data as above, and assuming that generate_potential
    !    has already been called, generate a StressData.
    procedure(generate_stress_PotentialData), public, deferred :: &
       & generate_stress
    
    ! Interpolation of the potential.
    procedure, public :: can_be_interpolated => &
                       & can_be_interpolated_PotentialData
    procedure, public :: interpolate_potential => &
                       & interpolate_potential_PotentialData
    procedure, public :: calculate_dynamical_matrices => &
                       & calculate_dynamical_matrices_PotentialData
    procedure, public :: energy_correction => &
                       & energy_correction_PotentialData
    
    ! Finalise the subspace potential.
    procedure, public :: optimise_subspace_potential => &
                       & optimise_subspace_potential_PotentialData
    
    ! Convert the potential to and from a set of real coefficients.
    ! Required for Pulay scheme.
    procedure(coefficients_PotentialData), public, deferred :: &
       & coefficients
    procedure(set_coefficients_PotentialData), public, deferred :: &
       & set_coefficients
    procedure(all_basis_functions_PotentialData), public, deferred :: &
       & all_basis_functions
    procedure(variable_basis_functions_PotentialData), public, deferred :: &
       & variable_basis_functions
  end type
  
  type, extends(PotentialData) :: PotentialPointer
    type(String),                      private :: representation_
    class(PotentialData), allocatable, private :: potential_
  contains
    procedure, private :: check => check_PotentialPointer
    
    procedure, public, nopass :: representation => &
                               & representation_PotentialPointer
    
    procedure, public :: potential => potential_potentialPointer
    
    procedure, public :: energy_RealModeDisplacement => &
                       & energy_RealModeDisplacement_PotentialPointer
    procedure, public :: energy_ComplexModeDisplacement => &
                       & energy_ComplexModeDisplacement_PotentialPointer
    procedure, public :: force_RealModeDisplacement => &
                       & force_RealModeDisplacement_PotentialPointer
    procedure, public :: force_ComplexModeDisplacement => &
                       & force_ComplexModeDisplacement_PotentialPointer
    
    procedure, public :: braket_SubspaceBraKet  => &
                       & braket_SubspaceBraKet_PotentialPointer
    procedure, public :: braket_BasisState  => &
                       & braket_BasisState_PotentialPointer
    procedure, public :: braket_BasisStates => &
                       & braket_BasisStates_PotentialPointer
    
    procedure, public :: harmonic_expectation => &
                       & harmonic_expectation_PotentialPointer
    
    procedure, public :: potential_energy_SubspaceBraKet => &
                       & potential_energy_SubspaceBraKet_PotentialPointer
    procedure, public :: potential_energy_BasisState => &
                       & potential_energy_BasisState_PotentialPointer
    
    procedure, public :: generate_sampling_points => &
       & generate_sampling_points_PotentialPointer
    procedure, public :: generate_potential => &
       & generate_potential_PotentialPointer
    procedure, public :: generate_stress => &
       & generate_stress_PotentialPointer
    
    procedure, public :: zero_energy => zero_energy_PotentialPointer
    procedure, public :: add_constant => add_constant_PotentialPointer
    
    procedure, public :: optimise_subspace_potential => &
                       & optimise_subspace_potential_PotentialPointer
    
    procedure, public :: coefficients => &
                       & coefficients_PotentialPointer
    procedure, public :: set_coefficients => &
                       & set_coefficients_PotentialPointer
    procedure, public :: all_basis_functions => &
                       & all_basis_functions_PotentialPointer
    procedure, public :: variable_basis_functions => &
                       & variable_basis_functions_PotentialPointer
    
    procedure, public :: can_be_interpolated => &
                       & can_be_interpolated_PotentialPointer
    procedure, public :: interpolate_potential => &
                       & interpolate_potential_PotentialPointer
    procedure, public :: calculate_dynamical_matrices => &
                       & calculate_dynamical_matrices_PotentialPointer
    procedure, public :: energy_correction => &
                       & energy_correction_PotentialPointer
    
    ! I/O.
    procedure, public :: read  => read_PotentialPointer
    procedure, public :: write => write_PotentialPointer
  end type
  
  abstract interface
    ! PotentialData procedures.
    impure elemental function representation_PotentialData() result(output)
      import String
      implicit none
      
      type(String) :: output
    end function
    
    subroutine generate_sampling_points_PotentialData(this,anharmonic_data, &
       & use_forces,energy_to_force_ratio,use_hessians,calculate_stress,    &
       & sampling_points_dir,calculation_writer,logfile)
      import PotentialData
      import AnharmonicData
      import dp
      import String
      import CalculationWriter
      import OFile
      implicit none
      
      class(PotentialData),    intent(inout) :: this
      type(AnharmonicData),    intent(in)    :: anharmonic_data
      logical,                 intent(in)    :: use_forces
      real(dp),                intent(in)    :: energy_to_force_ratio
      logical,                 intent(in)    :: use_hessians
      logical,                 intent(in)    :: calculate_stress
      type(String),            intent(in)    :: sampling_points_dir
      type(CalculationWriter), intent(inout) :: calculation_writer
      type(OFile),             intent(inout) :: logfile
    end subroutine
    
    subroutine generate_potential_PotentialData(this,anharmonic_data,        &
       & weighted_energy_force_ratio,sampling_points_dir,calculation_reader, &
       & logfile)
      import dp
      import PotentialData
      import AnharmonicData
      import String
      import CalculationReader
      import OFile
      implicit none
      
      class(PotentialData),    intent(inout) :: this
      type(AnharmonicData),    intent(in)    :: anharmonic_data
      real(dp),                intent(in)    :: weighted_energy_force_ratio
      type(String),            intent(in)    :: sampling_points_dir
      type(CalculationReader), intent(inout) :: calculation_reader
      type(OFile),             intent(inout) :: logfile
    end subroutine
    
    function generate_stress_PotentialData(this,anharmonic_data, &
       & sampling_points_dir,stress_expansion_order,             &
       & stress_subspace_coupling,vscf_basis_functions_only,     &
       & calculation_reader,logfile) result(output)
      import dp
      import PotentialData
      import AnharmonicData
      import String
      import SubspaceCoupling
      import CalculationReader
      import OFile
      import StressPointer
      implicit none
      
      class(PotentialData),    intent(in)    :: this
      type(AnharmonicData),    intent(in)    :: anharmonic_data
      type(String),            intent(in)    :: sampling_points_dir
      integer,                 intent(in)    :: stress_expansion_order
      type(SubspaceCoupling),  intent(in)    :: stress_subspace_coupling(:)
      logical,                 intent(in)    :: vscf_basis_functions_only
      type(CalculationReader), intent(inout) :: calculation_reader
      type(OFile),             intent(inout) :: logfile
      type(StressPointer)                    :: output
    end function
    
    function coefficients_PotentialData(this,anharmonic_data) &
       & result(output)
      import PotentialData
      import AnharmonicData
      import dp
      implicit none
      
      class(PotentialData), intent(in) :: this
      type(AnharmonicData), intent(in) :: anharmonic_data
      real(dp), allocatable            :: output(:)
    end function
    
    subroutine set_coefficients_PotentialData(this,coefficients, &
       & anharmonic_data)
      import PotentialData
      import AnharmonicData
      import dp
      implicit none
      
      class(PotentialData), intent(inout) :: this
      real(dp),             intent(in)    :: coefficients(:)
      type(AnharmonicData), intent(in)    :: anharmonic_data
    end subroutine
    
    function all_basis_functions_PotentialData(this,anharmonic_data) &
       & result(output)
      import PotentialData
      import AnharmonicData
      import PotentialBasePointer
      implicit none
      
      class(PotentialData), intent(in)        :: this
      type(AnharmonicData), intent(in)        :: anharmonic_data
      type(PotentialBasePointer), allocatable :: output(:)
    end function
    
    function variable_basis_functions_PotentialData(this,anharmonic_data) &
       & result(output)
      import PotentialData
      import AnharmonicData
      import PotentialBasePointer
      implicit none
      
      class(PotentialData), intent(in)        :: this
      type(AnharmonicData), intent(in)        :: anharmonic_data
      type(PotentialBasePointer), allocatable :: output(:)
    end function
  end interface
  
  interface
    module subroutine startup_PotentialData(this) 
      class(PotentialData), intent(in) :: this
    end subroutine
  end interface
  
  interface PotentialPointer
    ! Construct a PotentialPointer from any type which extends PotentialData.
    impure elemental module function new_PotentialPointer(potential) &
       & result(this) 
      class(PotentialData), intent(in) :: potential
      type(PotentialPointer)           :: this
    end function
  end interface
  
  interface
    ! Checks that the pointer has been allocated before it is used.
    impure elemental module subroutine check_PotentialPointer(this) 
      class(PotentialPointer), intent(in) :: this
    end subroutine
  end interface
  
  interface
    ! Type representation.
    impure elemental module function representation_PotentialPointer() &
       & result(output) 
      type(String) :: output
    end function
  end interface
  
  interface
    ! Return the stored potential.
    impure module function potential_PotentialPointer(this) result(output) 
      class(PotentialPointer), intent(in) :: this
      class(PotentialData), allocatable   :: output
    end function
  end interface
  
  interface
    ! Wrappers for all of PotentialData's methods.
    module subroutine generate_sampling_points_PotentialPointer(this,   &
       & anharmonic_data,use_forces,energy_to_force_ratio,use_hessians, &
       & calculate_stress,sampling_points_dir,calculation_writer,logfile) 
      class(PotentialPointer), intent(inout) :: this
      type(AnharmonicData),    intent(in)    :: anharmonic_data
      logical,                 intent(in)    :: use_forces
      real(dp),                intent(in)    :: energy_to_force_ratio
      logical,                 intent(in)    :: use_hessians
      logical,                 intent(in)    :: calculate_stress
      type(String),            intent(in)    :: sampling_points_dir
      type(CalculationWriter), intent(inout) :: calculation_writer
      type(OFile),             intent(inout) :: logfile
    end subroutine
  end interface
  
  interface
    module subroutine generate_potential_PotentialPointer(this,           &
       & anharmonic_data,weighted_energy_force_ratio,sampling_points_dir, &
       & calculation_reader,logfile) 
      class(PotentialPointer), intent(inout) :: this
      type(AnharmonicData),    intent(in)    :: anharmonic_data
      real(dp),                intent(in)    :: weighted_energy_force_ratio
      type(String),            intent(in)    :: sampling_points_dir
      type(CalculationReader), intent(inout) :: calculation_reader
      type(OFile),             intent(inout) :: logfile
    end subroutine
  end interface
  
  interface
    module function generate_stress_PotentialPointer(this,anharmonic_data, &
       & sampling_points_dir,stress_expansion_order,                       &
        stress_subspace_coupling,vscf_basis_functions_only, &
          & calculation_reader,logfile) result(output) 
      class(PotentialPointer), intent(in)    :: this
      type(AnharmonicData),    intent(in)    :: anharmonic_data
      type(String),            intent(in)    :: sampling_points_dir
      integer,                 intent(in)    :: stress_expansion_order
      type(SubspaceCoupling),  intent(in)    :: stress_subspace_coupling(:)
      logical,intent(in) :: vscf_basis_functions_only
      type(CalculationReader), intent(inout) :: calculation_reader
      type(OFile),             intent(inout) :: logfile
      type(StressPointer)                    :: output
    end function
  end interface
  
  interface
    impure elemental module subroutine zero_energy_PotentialPointer(this) 
      class(PotentialPointer), intent(inout) :: this
    end subroutine
  end interface
  
  interface
    impure elemental module subroutine add_constant_PotentialPointer(this, &
       & input) 
      class(PotentialPointer), intent(inout) :: this
      real(dp),                intent(in)    :: input
    end subroutine
  end interface
  
  interface
    module subroutine optimise_subspace_potential_PotentialPointer(this, &
       & subspace,subspace_basis,old_subspace_potential,anharmonic_data) 
      class(PotentialPointer),  intent(inout)        :: this
      type(DegenerateSubspace), intent(in)           :: subspace
      class(SubspaceBasis),     intent(in)           :: subspace_basis
      class(PotentialData),     intent(in), optional :: old_subspace_potential
      type(AnharmonicData),     intent(in)           :: anharmonic_data
    end subroutine
  end interface
  
  interface
    impure elemental module function energy_RealModeDisplacement_PotentialPointer(this,displacement) result(output) 
      class(PotentialPointer),    intent(in) :: this
      type(RealModeDisplacement), intent(in) :: displacement
      real(dp)                               :: output
    end function
  end interface
  
  interface
    impure elemental module function energy_ComplexModeDisplacement_PotentialPointer(   this,displacement) result(output) 
      class(PotentialPointer),       intent(in) :: this
      type(ComplexModeDisplacement), intent(in) :: displacement
      complex(dp)                               :: output
    end function
  end interface
  
  interface
    impure elemental module function force_RealModeDisplacement_PotentialPointer(this,displacement) result(output) 
      class(PotentialPointer),    intent(in) :: this
      type(RealModeDisplacement), intent(in) :: displacement
      type(RealModeForce)                    :: output
    end function
  end interface
  
  interface
    impure elemental module function force_ComplexModeDisplacement_PotentialPointer(   this,displacement) result(output) 
      class(PotentialPointer),       intent(in) :: this
      type(ComplexModeDisplacement), intent(in) :: displacement
      type(ComplexModeForce)                    :: output
    end function
  end interface
  
  interface
    impure elemental module subroutine braket_SubspaceBraKet_PotentialPointer(this,braket,whole_subspace,anharmonic_data) 
      class(PotentialPointer), intent(inout)        :: this
      class(SubspaceBraKet),   intent(in)           :: braket
      logical,                 intent(in), optional :: whole_subspace
      type(AnharmonicData),    intent(in)           :: anharmonic_data
    end subroutine
  end interface
  
  interface
    impure elemental module subroutine braket_BasisState_PotentialPointer(this,bra,ket,subspace,subspace_basis,whole_subspace,anharmonic_data) 
      class(PotentialPointer),  intent(inout)        :: this
      class(BasisState),        intent(in)           :: bra
      class(BasisState),        intent(in), optional :: ket
      type(DegenerateSubspace), intent(in)           :: subspace
      class(SubspaceBasis),     intent(in)           :: subspace_basis
      logical,                  intent(in), optional :: whole_subspace
      type(AnharmonicData),     intent(in)           :: anharmonic_data
    end subroutine
  end interface
  
  interface
    impure elemental module subroutine braket_BasisStates_PotentialPointer(this,states,subspace,subspace_basis,whole_subspace,anharmonic_data) 
      class(PotentialPointer),  intent(inout)        :: this
      class(BasisStates),       intent(inout)        :: states
      type(DegenerateSubspace), intent(in)           :: subspace
      class(SubspaceBasis),     intent(in)           :: subspace_basis
      logical,                  intent(in), optional :: whole_subspace
      type(AnharmonicData),     intent(in)           :: anharmonic_data
    end subroutine
  end interface
  
  interface
    impure elemental module function harmonic_expectation_PotentialPointer(this,frequency,thermal_energy,supercell_size,anharmonic_data) result(output) 
      class(PotentialPointer), intent(in) :: this
      real(dp),                intent(in) :: frequency
      real(dp),                intent(in) :: thermal_energy
      integer,                 intent(in) :: supercell_size
      type(AnharmonicData),    intent(in) :: anharmonic_data
      real(dp)                            :: output
    end function
  end interface
  
  interface
    recursive module function potential_energy_SubspaceBraKet_PotentialPointer(this,braket,anharmonic_data) result(output) 
      class(PotentialPointer), intent(in) :: this
      class(SubspaceBraKet),   intent(in) :: braket
      type(AnharmonicData),    intent(in) :: anharmonic_data
      real(dp)                            :: output
    end function
  end interface
  
  interface
    recursive module function potential_energy_BasisState_PotentialPointer(this,bra,ket,subspace,subspace_basis,anharmonic_data) result(output) 
      class(PotentialPointer),  intent(in)           :: this
      class(BasisState),        intent(in)           :: bra
      class(BasisState),        intent(in), optional :: ket
      type(DegenerateSubspace), intent(in)           :: subspace
      class(SubspaceBasis),     intent(in)           :: subspace_basis
      type(AnharmonicData),     intent(in)           :: anharmonic_data
      real(dp)                                       :: output
    end function
  end interface
  
  interface
    module function coefficients_PotentialPointer(this,anharmonic_data) &
       & result(output) 
      class(PotentialPointer), intent(in) :: this
      type(AnharmonicData),    intent(in) :: anharmonic_data
      real(dp), allocatable               :: output(:)
    end function
  end interface
  
  interface
    module subroutine set_coefficients_PotentialPointer(this,coefficients, &
       & anharmonic_data) 
      class(PotentialPointer), intent(inout) :: this
      real(dp),                intent(in)    :: coefficients(:)
      type(AnharmonicData),    intent(in)    :: anharmonic_data
    end subroutine
  end interface
  
  interface
    module function all_basis_functions_PotentialPointer(this, &
       & anharmonic_data) result(output) 
      class(PotentialPointer), intent(in)     :: this
      type(AnharmonicData),    intent(in)     :: anharmonic_data
      type(PotentialBasePointer), allocatable :: output(:)
    end function
  end interface
  
  interface
    module function variable_basis_functions_PotentialPointer(this, &
       & anharmonic_data) result(output) 
      class(PotentialPointer), intent(in)     :: this
      type(AnharmonicData),    intent(in)     :: anharmonic_data
      type(PotentialBasePointer), allocatable :: output(:)
    end function
  end interface
  
  interface
    module function can_be_interpolated_PotentialPointer(this) result(output) 
      class(PotentialPointer), intent(in) :: this
      logical                             :: output
    end function
  end interface
  
  interface
    module subroutine interpolate_potential_PotentialPointer(this, &
       & anharmonic_min_images,potential,anharmonic_data,          &
       & interpolated_anharmonic_data,difference_dynamical_matrices,logfile) 
      class(PotentialPointer), intent(inout) :: this
      type(MinImages),         intent(in)    :: anharmonic_min_images(:,:)
      class(PotentialData),    intent(in)    :: potential
      type(AnharmonicData),    intent(in)    :: anharmonic_data
      type(AnharmonicData),    intent(in)    :: interpolated_anharmonic_data
      type(DynamicalMatrix),   intent(in)    :: difference_dynamical_matrices(:)
      type(OFile),             intent(inout) :: logfile
    end subroutine
  end interface
  
  interface
    module function calculate_dynamical_matrices_PotentialPointer(this,   &
       & qpoints,thermal_energy,subspaces,subspace_bases,subspace_states, &
       & anharmonic_data) result(output) 
      class(PotentialPointer),  intent(in)    :: this
      type(QpointData),         intent(in)    :: qpoints(:)
      real(dp),                 intent(in)    :: thermal_energy
      type(DegenerateSubspace), intent(in)    :: subspaces(:)
      class(SubspaceBasis),     intent(in)    :: subspace_bases(:)
      class(BasisStates),       intent(inout) :: subspace_states(:)
      type(AnharmonicData),     intent(in)    :: anharmonic_data
      type(DynamicalMatrix), allocatable      :: output(:)
    end function
  end interface
  
  interface
    module function energy_correction_PotentialPointer(this,subspaces, &
       & subspace_bases,subspace_states,anharmonic_data) result(output) 
      class(PotentialPointer),  intent(in)    :: this
      type(DegenerateSubspace), intent(in)    :: subspaces(:)
      class(SubspaceBasis),     intent(in)    :: subspace_bases(:)
      class(BasisStates),       intent(inout) :: subspace_states(:)
      type(AnharmonicData),     intent(in)    :: anharmonic_data
      real(dp)                                :: output
    end function
  end interface
  
  interface
    ! Concrete PotentialData methods.
    module function can_be_interpolated_PotentialData(this) result(output) 
      class(PotentialData), intent(in) :: this
      logical                          :: output
    end function
  end interface
  
  interface
    module subroutine interpolate_potential_PotentialData(this, &
       & anharmonic_min_images,potential,anharmonic_data,       &
       & interpolated_anharmonic_data,difference_dynamical_matrices,logfile) 
      class(PotentialData),  intent(inout) :: this
      type(MinImages),       intent(in)    :: anharmonic_min_images(:,:)
      class(PotentialData),  intent(in)    :: potential
      type(AnharmonicData),  intent(in)    :: anharmonic_data
      type(AnharmonicData),  intent(in)    :: interpolated_anharmonic_data
      type(DynamicalMatrix), intent(in)    :: difference_dynamical_matrices(:)
      type(OFile),           intent(inout) :: logfile
    end subroutine
  end interface
  
  interface
    module function calculate_dynamical_matrices_PotentialData(this,qpoints, &
       & thermal_energy,subspaces,subspace_bases,subspace_states,            &
       & anharmonic_data) result(output) 
      class(PotentialData),     intent(in)    :: this
      type(QpointData),         intent(in)    :: qpoints(:)
      real(dp),                 intent(in)    :: thermal_energy
      type(DegenerateSubspace), intent(in)    :: subspaces(:)
      class(SubspaceBasis),     intent(in)    :: subspace_bases(:)
      class(BasisStates),       intent(inout) :: subspace_states(:)
      type(AnharmonicData),     intent(in)    :: anharmonic_data
      type(DynamicalMatrix), allocatable      :: output(:)
    end function
  end interface
  
  interface
    module function energy_correction_PotentialData(this,subspaces, &
       & subspace_bases,subspace_states,anharmonic_data) result(output) 
      class(PotentialData),     intent(in)    :: this
      type(DegenerateSubspace), intent(in)    :: subspaces(:)
      class(SubspaceBasis),     intent(in)    :: subspace_bases(:)
      class(BasisStates),       intent(inout) :: subspace_states(:)
      type(AnharmonicData),     intent(in)    :: anharmonic_data
      real(dp)                                :: output
    end function
  end interface
  
  interface
    module subroutine optimise_subspace_potential_PotentialData(this, &
       & subspace,subspace_basis,old_subspace_potential,anharmonic_data) 
      class(PotentialData),     intent(inout)        :: this
      type(DegenerateSubspace), intent(in)           :: subspace
      class(SubspaceBasis),     intent(in)           :: subspace_basis
      class(PotentialData),     intent(in), optional :: old_subspace_potential
      type(AnharmonicData),     intent(in)           :: anharmonic_data
    end subroutine
  end interface
  
  interface
    ! I/O.
    module subroutine read_PotentialPointer(this,input) 
      class(PotentialPointer), intent(out) :: this
      type(String),            intent(in)  :: input(:)
    end subroutine
  end interface
  
  interface
    module function write_PotentialPointer(this) result(output) 
      class(PotentialPointer), intent(in) :: this
      type(String), allocatable           :: output(:)
    end function
  end interface
  
  interface PotentialPointer
    module function new_PotentialPointer_Strings(input) result(this) 
      type(String), intent(in) :: input(:)
      type(PotentialPointer)   :: this
    end function
  
    impure elemental module function new_PotentialPointer_StringArray(input) &
       & result(this) 
      type(StringArray), intent(in) :: input
      type(PotentialPointer)        :: this
    end function
  end interface
end module
