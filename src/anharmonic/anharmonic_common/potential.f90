! ======================================================================
! The abstract potential type.
! ======================================================================
! See the example module in potential_pointer.f90 for how to use this type.
module potential_module
  use common_module
  
  use anharmonic_data_module
  implicit none
  
  private
  
  public :: PotentialData
  public :: WriteLambda
  public :: ReadLambda
  
  type, abstract, extends(NoDefaultConstructor) :: PotentialData
  contains
    ! Given all input data, generate the set of sampling points at which
    !    electronic structure calculations should be run in order to
    !    map out the potential.
    procedure(generate_sampling_points_PotentialData), public, deferred :: &
       & generate_sampling_points
    
    ! Given the same data as above, generate the potential.
    ! All electronic structure calculations generated by
    !    generate_sampling_points will all have been run.
    procedure(generate_potential_PotentialData), public, deferred :: &
       & generate_potential
  end type
  
  interface
    ! Takes a structure and a directory name,
    !    makes the directory and sets up an electronic structure calculation
    !    based on the structure.
    ! Function implementation defined in run_anharmonic.f90.
    subroutine WriteLambda(structure,directory)
      import StructureData
      import String
      implicit none
      
      type(StructureData), intent(in) :: structure
      type(String),        intent(in) :: directory
    end subroutine
    
    ! Reads the results of the electronic structure calculation from the
    !    given directory.
    ! Function implementation defined in calculate_anharmonic.f90.
    function ReadLambda(directory) result(output)
      import String
      import ElectronicStructure
      
      type(String), intent(in)  :: directory
      type(ElectronicStructure) :: output
    end function
  end interface
  
  abstract interface
    subroutine generate_sampling_points_PotentialData(this,inputs, &
       & sampling_points_dir,logfile,write_lambda)
      import PotentialData
      import AnharmonicData
      import String
      import OFile
      implicit none
      
      class(PotentialData), intent(inout) :: this
      type(AnharmonicData), intent(in)    :: inputs
      type(String),         intent(in)    :: sampling_points_dir
      type(OFile),          intent(inout) :: logfile
      procedure(WriteLambda)              :: write_lambda
    end subroutine
    
    subroutine generate_potential_PotentialData(this,inputs, &
       & sampling_points_dir,logfile,read_lambda)
      import PotentialData
      import AnharmonicData
      import String
      import OFile
      implicit none
      
      class(PotentialData), intent(inout) :: this
      type(AnharmonicData), intent(in)    :: inputs
      type(String),         intent(in)    :: sampling_points_dir
      type(OFile),          intent(inout) :: logfile
      procedure(ReadLambda)               :: read_lambda
    end subroutine
  end interface
contains
end module
